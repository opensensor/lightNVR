#!/usr/bin/env python3
"""Generate embedded migrations C header from SQL migration files.

Usage: python3 generate_embedded_migrations.py <migrations_dir> <output_header>
"""

import os
import re
import sys
import glob


def escape_c_string(s):
    """Escape a string for use as a C string literal."""
    s = s.replace('\\', '\\\\')
    s = s.replace('"', '\\"')
    lines = s.split('\n')
    return '\\n"\n    "'.join(lines)


def extract_section(content, section):
    """Extract the up or down section from a migration file."""
    pattern = rf'--\s*migrate:{section}\s*\n(.*?)(?=--\s*migrate:|$)'
    match = re.search(pattern, content, re.DOTALL | re.IGNORECASE)
    if match:
        return match.group(1).strip()
    return ""


def main():
    if len(sys.argv) != 3:
        print(f"Usage: {sys.argv[0]} <migrations_dir> <output_header>", file=sys.stderr)
        sys.exit(1)

    migrations_dir = sys.argv[1]
    output_file = sys.argv[2]

    sql_files = sorted(glob.glob(os.path.join(migrations_dir, "*.sql")))

    if not sql_files:
        print(f"No SQL files found in {migrations_dir}", file=sys.stderr)
        sys.exit(1)

    os.makedirs(os.path.dirname(output_file) or '.', exist_ok=True)

    migrations = []
    for sql_file in sql_files:
        basename = os.path.splitext(os.path.basename(sql_file))[0]
        match = re.match(r'^(\d+)_(.+)$', basename)
        if not match:
            continue
        version = match.group(1)
        description = match.group(2)

        content = open(sql_file, 'r').read()
        up_sql = extract_section(content, 'up')
        down_sql = extract_section(content, 'down')

        migrations.append((version, description, up_sql, down_sql))

    with open(output_file, 'w') as f:
        f.write("/**\n")
        f.write(" * @file db_embedded_migrations.h\n")
        f.write(" * @brief Auto-generated embedded SQL migrations.\n")
        f.write(" * DO NOT EDIT - generated by scripts/generate_embedded_migrations.py\n")
        f.write(" */\n\n")
        f.write("#ifndef DB_EMBEDDED_MIGRATIONS_H\n")
        f.write("#define DB_EMBEDDED_MIGRATIONS_H\n\n")
        f.write('#include "database/sqlite_migrate.h"\n\n')

        # Write SQL string constants
        for version, description, up_sql, down_sql in migrations:
            up_c = escape_c_string(up_sql)
            down_c = escape_c_string(down_sql)
            f.write(f'static const char migration_{version}_up[] =\n')
            f.write(f'    "{up_c}";\n\n')
            f.write(f'static const char migration_{version}_down[] =\n')
            f.write(f'    "{down_c}";\n\n')

        # Write the array
        f.write("static const migration_t embedded_migrations_data[] = {\n")
        for version, description, _, _ in migrations:
            desc_truncated = description[:255]
            f.write(f'    {{\n')
            f.write(f'        .version = "{version}",\n')
            f.write(f'        .description = "{desc_truncated}",\n')
            f.write(f'        .sql_up = migration_{version}_up,\n')
            f.write(f'        .sql_down = migration_{version}_down,\n')
            f.write(f'        .is_embedded = true\n')
            f.write(f'    }},\n')
        f.write("};\n\n")

        count = len(migrations)
        f.write(f"#define EMBEDDED_MIGRATIONS_COUNT {count}\n\n")
        f.write("#endif /* DB_EMBEDDED_MIGRATIONS_H */\n")

    print(f"Generated {output_file} with {count} embedded migrations")


if __name__ == '__main__':
    main()

