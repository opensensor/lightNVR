{"version":3,"file":"TimelineView-legacy-nDkz7QHG.js","sources":["../../js/components/preact/timeline/TimelineControls.js","../../js/components/preact/timeline/TimelineRuler.js","../../js/components/preact/timeline/TimelineSegments.js","../../js/components/preact/timeline/TimelineCursor.js","../../js/components/preact/timeline/SpeedControls.js","../../js/components/preact/timeline/TimelinePlayer.js","../../js/components/preact/timeline/TimelineView.js","../../js/components/preact/timeline/TimelinePage.js"],"sourcesContent":["/**\n * LightNVR Timeline Controls Component\n * Handles play/pause and zoom controls for the timeline\n */\n\n\nimport { html } from '../../../html-helper.js';\nimport { useState, useEffect } from 'preact/hooks';\nimport { timelineState } from './TimelinePage.js';\nimport { showStatusMessage } from '../UI.js';\n\n/**\n * TimelineControls component\n * @returns {JSX.Element} TimelineControls component\n */\nexport function TimelineControls() {\n  // Local state\n  const [isPlaying, setIsPlaying] = useState(false);\n  const [zoomLevel, setZoomLevel] = useState(1);\n\n  // Subscribe to timeline state changes\n  useEffect(() => {\n    const unsubscribe = timelineState.subscribe(state => {\n      setIsPlaying(state.isPlaying);\n      setZoomLevel(state.zoomLevel);\n    });\n\n    return () => unsubscribe();\n  }, []);\n\n  // Toggle playback (play/pause)\n  const togglePlayback = () => {\n    console.log('TimelineControls: togglePlayback called');\n    console.log('TimelineControls: Current state before toggle:', {\n      isPlaying,\n      currentTime: timelineState.currentTime,\n      currentSegmentIndex: timelineState.currentSegmentIndex,\n      segmentsCount: timelineState.timelineSegments ? timelineState.timelineSegments.length : 0\n    });\n\n    if (isPlaying) {\n      pausePlayback();\n    } else {\n      resumePlayback();\n    }\n  };\n\n  // Pause playback\n  const pausePlayback = () => {\n    timelineState.setState({ isPlaying: false });\n\n    // If there's a video player, pause it\n    const videoPlayer = document.querySelector('#video-player video');\n    if (videoPlayer) {\n      videoPlayer.pause();\n    }\n  };\n\n  // Resume playback\n  const resumePlayback = () => {\n    // If no segments, show message and return\n    if (!timelineState.timelineSegments || timelineState.timelineSegments.length === 0) {\n      showStatusMessage('No recordings to play', 'warning');\n      return;\n    }\n\n    console.log('TimelineControls: resumePlayback called');\n    console.log('TimelineControls: Current state:', {\n      segments: timelineState.timelineSegments.length,\n      currentSegmentIndex: timelineState.currentSegmentIndex,\n      currentTime: timelineState.currentTime,\n      selectedDate: timelineState.selectedDate\n    });\n\n    // SIMPLIFIED APPROACH: Directly use the current time to find the appropriate segment\n    let segmentToPlay = null;\n    let segmentIndex = -1;\n    let relativeTime = 0;\n\n    // If we have a current time, find the segment that contains it\n    if (timelineState.currentTime !== null) {\n      console.log('TimelineControls: Using current time to find segment:', timelineState.currentTime);\n\n      // First try to find a segment that contains the current time\n      for (let i = 0; i < timelineState.timelineSegments.length; i++) {\n        const segment = timelineState.timelineSegments[i];\n        if (timelineState.currentTime >= segment.start_timestamp &&\n            timelineState.currentTime <= segment.end_timestamp) {\n          segmentToPlay = segment;\n          segmentIndex = i;\n          relativeTime = timelineState.currentTime - segment.start_timestamp;\n          console.log(`TimelineControls: Found segment ${i} containing current time, relative time: ${relativeTime}s`);\n          break;\n        }\n      }\n\n      // If no exact match, find the closest segment\n      if (!segmentToPlay) {\n        let closestIndex = 0;\n        let minDistance = Infinity;\n\n        for (let i = 0; i < timelineState.timelineSegments.length; i++) {\n          const segment = timelineState.timelineSegments[i];\n          const midpoint = (segment.start_timestamp + segment.end_timestamp) / 2;\n          const distance = Math.abs(timelineState.currentTime - midpoint);\n\n          if (distance < minDistance) {\n            minDistance = distance;\n            closestIndex = i;\n          }\n        }\n\n        segmentToPlay = timelineState.timelineSegments[closestIndex];\n        segmentIndex = closestIndex;\n        // If the current time is after the segment, start at the beginning\n        if (timelineState.currentTime < segmentToPlay.start_timestamp) {\n          relativeTime = 0;\n        } else {\n          // Otherwise, start at the end\n          relativeTime = 0;\n        }\n\n        console.log(`TimelineControls: Using closest segment ${closestIndex}, relative time: ${relativeTime}s`);\n      }\n    }\n    // If no current time but we have a valid segment index, use that\n    else if (timelineState.currentSegmentIndex >= 0 &&\n             timelineState.currentSegmentIndex < timelineState.timelineSegments.length) {\n      segmentIndex = timelineState.currentSegmentIndex;\n      segmentToPlay = timelineState.timelineSegments[segmentIndex];\n      relativeTime = 0;\n      console.log(`TimelineControls: Using current segment index ${segmentIndex}`);\n    }\n    // Fall back to the first segment\n    else {\n      segmentIndex = 0;\n      segmentToPlay = timelineState.timelineSegments[0];\n      relativeTime = 0;\n      console.log('TimelineControls: Falling back to first segment');\n    }\n\n    // DIRECT APPROACH: Manually load and play the video\n    console.log(`TimelineControls: Playing segment ${segmentIndex} (ID: ${segmentToPlay.id}) at time ${relativeTime}s`);\n\n    // First update the state\n    timelineState.currentSegmentIndex = segmentIndex;\n    timelineState.currentTime = segmentToPlay.start_timestamp + relativeTime;\n    timelineState.isPlaying = true;\n    timelineState.directVideoControl = true; // Set flag to prevent TimelinePlayer interference\n\n    // Notify listeners\n    timelineState.setState({});\n\n    // Keep the directVideoControl flag active longer to ensure no interference\n    const resetDirectControl = () => {\n      console.log('TimelineControls: Resetting directVideoControl flag');\n      timelineState.directVideoControl = false;\n      timelineState.setState({});\n    };\n\n    // Reset the flag after a longer delay\n    setTimeout(resetDirectControl, 3000);\n\n    // Now directly control the video element\n    const videoElement = document.querySelector('#video-player video');\n    if (videoElement) {\n      // Pause any current playback\n      videoElement.pause();\n\n      // Set up event listener for when metadata is loaded\n      const handleMetadataLoaded = () => {\n        console.log(`TimelineControls: Video metadata loaded, setting time to ${relativeTime}s`);\n\n        try {\n          // Log the video duration\n          console.log('TimelineControls: Video metadata', {\n            duration: videoElement.duration,\n            width: videoElement.videoWidth,\n            height: videoElement.videoHeight,\n            segment: segmentToPlay.id,\n            segmentDuration: segmentToPlay.end_timestamp - segmentToPlay.start_timestamp\n          });\n\n          // Set the current time\n          const validTime = Math.max(0, Math.min(relativeTime, videoElement.duration || 0));\n          videoElement.currentTime = validTime;\n\n          // Start playback with a small delay to avoid conflicts\n          setTimeout(() => {\n            if (timelineState.isPlaying) {\n              console.log('TimelineControls: Starting video playback');\n              videoElement.play().then(() => {\n                console.log('TimelineControls: Video playback started successfully');\n\n                // Set up multiple checks to ensure playback continues\n                const checkPlayback = (attempt = 1) => {\n                  if (attempt > 5) return; // Limit to 5 attempts\n\n                  setTimeout(() => {\n                    if (videoElement.paused && timelineState.isPlaying) {\n                      console.log(`TimelineControls: Video paused unexpectedly (attempt ${attempt}), trying to resume`);\n                      videoElement.play().catch(e => {\n                        console.error(`Error resuming video (attempt ${attempt}):`, e);\n                      });\n\n                      // Try again after a delay\n                      checkPlayback(attempt + 1);\n                    }\n                  }, 500 * attempt); // Increasing delays between attempts\n                };\n\n                // Start the playback checks\n                checkPlayback();\n\n                // Set up a check to ensure the video plays for the full segment duration\n                const segmentDuration = segmentToPlay.end_timestamp - segmentToPlay.start_timestamp;\n                console.log(`TimelineControls: Segment duration: ${segmentDuration}s, video duration: ${videoElement.duration}s`);\n\n                // If the video duration is significantly shorter than the segment duration,\n                // we need to ensure the video plays for the full segment duration\n                if (videoElement.duration < segmentDuration - 1) { // Allow 1 second tolerance\n                  console.log('TimelineControls: Video duration is shorter than segment duration, will monitor playback');\n\n                  // Monitor playback to ensure it continues for the full segment duration\n                  const monitorInterval = setInterval(() => {\n                    if (!timelineState.isPlaying || !videoElement) {\n                      clearInterval(monitorInterval);\n                      return;\n                    }\n\n                    // If we're near the end of the video but not the end of the segment,\n                    // reset to the beginning and continue playing\n                    if (videoElement.currentTime > videoElement.duration - 0.5 &&\n                        relativeTime + videoElement.currentTime < segmentDuration) {\n                      console.log('TimelineControls: Reached end of video but not end of segment, restarting video');\n                      videoElement.currentTime = 0;\n                      videoElement.play().catch(e => {\n                        console.error('Error restarting video:', e);\n                      });\n                    }\n                  }, 500);\n                }\n              }).catch(e => {\n                console.error('Error playing video:', e);\n                showStatusMessage('Error playing video: ' + e.message, 'error');\n              });\n            }\n          }, 100);\n        } catch (error) {\n          console.error('TimelineControls: Error in handleMetadataLoaded:', error);\n        } finally {\n          // Remove the event listener\n          videoElement.removeEventListener('loadedmetadata', handleMetadataLoaded);\n        }\n      };\n\n      // Add the event listener\n      videoElement.addEventListener('loadedmetadata', handleMetadataLoaded);\n\n      // Set the new source\n      console.log(`TimelineControls: Loading video from segment ${segmentToPlay.id}`);\n      videoElement.src = `/api/recordings/play/${segmentToPlay.id}?t=${Date.now()}`;\n      videoElement.load();\n    } else {\n      console.error('TimelineControls: No video element found');\n      showStatusMessage('Error: Video player not found', 'error');\n    }\n  };\n\n  // Play a specific segment\n  const playSegment = (index) => {\n    // This function will be implemented in the TimelinePlayer component\n    // Here we just update the state\n    timelineState.setState({\n      currentSegmentIndex: index,\n      isPlaying: true\n    });\n  };\n\n  // Zoom in on timeline\n  const zoomIn = () => {\n    if (zoomLevel < 8) {\n      const newZoomLevel = zoomLevel * 2;\n      timelineState.setState({ zoomLevel: newZoomLevel });\n      showStatusMessage(`Zoomed in: ${24 / newZoomLevel} hours view`, 'info');\n    }\n  };\n\n  // Zoom out on timeline\n  const zoomOut = () => {\n    if (zoomLevel > 1) {\n      const newZoomLevel = zoomLevel / 2;\n      timelineState.setState({ zoomLevel: newZoomLevel });\n      showStatusMessage(`Zoomed out: ${24 / newZoomLevel} hours view`, 'info');\n    }\n  };\n\n  return html`\n    <div class=\"timeline-controls flex justify-between items-center mb-2\">\n      <div class=\"flex items-center\">\n        <button\n          id=\"play-button\"\n          class=\"w-10 h-10 rounded-full bg-green-600 hover:bg-green-700 text-white flex items-center justify-center focus:outline-none focus:ring-1 focus:ring-green-500 focus:ring-offset-1 transition-colors shadow-sm mr-2\"\n          onClick=${togglePlayback}\n          title=${isPlaying ? 'Pause' : 'Play from current position'}\n        >\n          <svg xmlns=\"http://www.w3.org/2000/svg\" class=\"h-5 w-5\" fill=\"none\" viewBox=\"0 0 24 24\" stroke=\"currentColor\">\n            ${isPlaying\n              ? html`\n                <!-- Pause icon - two vertical bars -->\n                <rect x=\"6\" y=\"6\" width=\"4\" height=\"12\" rx=\"1\" fill=\"white\" />\n                <rect x=\"14\" y=\"6\" width=\"4\" height=\"12\" rx=\"1\" fill=\"white\" />\n              `\n              : html`\n                <!-- Play icon - triangle -->\n                <path d=\"M8 5.14v14l11-7-11-7z\" fill=\"white\" />\n              `\n            }\n          </svg>\n        </button>\n        <span class=\"text-xs text-gray-600 dark:text-gray-300\">Play from current position</span>\n      </div>\n\n      <div class=\"flex items-center gap-1\">\n        <span class=\"text-xs text-gray-600 dark:text-gray-300 mr-1\">Zoom:</span>\n        <button\n          id=\"zoom-out-button\"\n          class=\"w-6 h-6 rounded bg-gray-200 dark:bg-gray-700 hover:bg-gray-300 dark:hover:bg-gray-600 flex items-center justify-center focus:outline-none focus:ring-1 focus:ring-blue-500 transition-colors\"\n          onClick=${zoomOut}\n          title=\"Zoom Out (Show more time)\"\n          disabled=${zoomLevel <= 1}\n        >\n          <svg xmlns=\"http://www.w3.org/2000/svg\" class=\"h-4 w-4\" fill=\"none\" viewBox=\"0 0 24 24\" stroke=\"currentColor\">\n            <path stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\" d=\"M15 12H9m12 0a9 9 0 11-18 0 9 9 0 0118 0z\" />\n          </svg>\n        </button>\n        <button\n          id=\"zoom-in-button\"\n          class=\"w-6 h-6 rounded bg-gray-200 dark:bg-gray-700 hover:bg-gray-300 dark:hover:bg-gray-600 flex items-center justify-center focus:outline-none focus:ring-1 focus:ring-blue-500 transition-colors\"\n          onClick=${zoomIn}\n          title=\"Zoom In (Show less time)\"\n          disabled=${zoomLevel >= 8}\n        >\n          <svg xmlns=\"http://www.w3.org/2000/svg\" class=\"h-4 w-4\" fill=\"none\" viewBox=\"0 0 24 24\" stroke=\"currentColor\">\n            <path stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\" d=\"M12 9v3m0 0v3m0-3h3m-3 0H9m12 0a9 9 0 11-18 0 9 9 0 0118 0z\" />\n          </svg>\n        </button>\n      </div>\n    </div>\n  `;\n}\n","/**\n * LightNVR Timeline Ruler Component\n * Displays the time ruler with hour markers\n */\n\nimport { html } from '../../../html-helper.js';\nimport { useState, useEffect } from 'preact/hooks';\nimport { timelineState } from './TimelinePage.js';\n\n/**\n * TimelineRuler component\n * @returns {JSX.Element} TimelineRuler component\n */\nexport function TimelineRuler() {\n  // Local state\n  const [startHour, setStartHour] = useState(0);\n  const [endHour, setEndHour] = useState(24);\n  const [zoomLevel, setZoomLevel] = useState(1);\n\n  // Subscribe to timeline state changes\n  useEffect(() => {\n    const unsubscribe = timelineState.subscribe(state => {\n      console.log('TimelineRuler: State update received', {\n        zoomLevel: state.zoomLevel,\n        segmentsCount: state.timelineSegments ? state.timelineSegments.length : 0,\n        currentTime: state.currentTime\n      });\n\n      // Calculate time range based on zoom level\n      const hoursPerView = 24 / state.zoomLevel;\n\n      // Calculate the center hour based on current time or segments\n      let centerHour = 12; // Default to noon\n\n      if (state.currentTime !== null) {\n        // If we have a current time, use it as the center\n        const currentDate = new Date(state.currentTime * 1000);\n        centerHour = currentDate.getHours() + (currentDate.getMinutes() / 60) + (currentDate.getSeconds() / 3600);\n      } else if (state.timelineSegments && state.timelineSegments.length > 0) {\n        // If we have segments but no current time, use the middle of the segments\n        let earliestHour = 24;\n        let latestHour = 0;\n\n        state.timelineSegments.forEach(segment => {\n          const startTime = new Date(segment.start_timestamp * 1000);\n          const endTime = new Date(segment.end_timestamp * 1000);\n\n          const startHour = startTime.getHours() + (startTime.getMinutes() / 60) + (startTime.getSeconds() / 3600);\n          const endHour = endTime.getHours() + (endTime.getMinutes() / 60) + (endTime.getSeconds() / 3600);\n\n          earliestHour = Math.min(earliestHour, startHour);\n          latestHour = Math.max(latestHour, endHour);\n        });\n\n        centerHour = (earliestHour + latestHour) / 2;\n        console.log('TimelineRuler: Calculated center from segments', { earliestHour, latestHour, centerHour });\n      }\n\n      // Calculate start and end hours based on center and zoom level\n      let newStartHour = Math.max(0, centerHour - (hoursPerView / 2));\n      let newEndHour = Math.min(24, newStartHour + hoursPerView);\n\n      // Adjust start hour if end hour is at the limit\n      if (newEndHour === 24 && hoursPerView < 24) {\n        newStartHour = Math.max(0, 24 - hoursPerView);\n        newEndHour = 24;\n      } else if (newStartHour === 0 && hoursPerView < 24) {\n        newEndHour = Math.min(24, hoursPerView);\n      }\n\n      // Update local state\n      setStartHour(newStartHour);\n      setEndHour(newEndHour);\n      setZoomLevel(state.zoomLevel);\n\n      console.log('TimelineRuler: Calculated time range', {\n        newStartHour,\n        newEndHour,\n        hoursPerView,\n        centerHour\n      });\n\n      // Only update global state if the values have actually changed\n      // to prevent infinite recursion\n      if (timelineState.timelineStartHour !== newStartHour ||\n          timelineState.timelineEndHour !== newEndHour) {\n        console.log('TimelineRuler: Updating global state with new time range');\n        timelineState.setState({\n          timelineStartHour: newStartHour,\n          timelineEndHour: newEndHour\n        });\n      }\n    });\n\n    return () => unsubscribe();\n  }, []);\n\n  // Generate hour markers and labels\n  const generateHourMarkers = () => {\n    const markers = [];\n    const hourWidth = 100 / (endHour - startHour);\n\n    // Add hour markers and labels\n    for (let hour = Math.floor(startHour); hour <= Math.ceil(endHour); hour++) {\n      if (hour >= 0 && hour <= 24) {\n        const position = ((hour - startHour) / (endHour - startHour)) * 100;\n\n        // Add hour marker\n        markers.push(html`\n          <div\n            key=\"tick-${hour}\"\n            class=\"absolute top-0 w-px h-5 bg-gray-500 dark:bg-gray-400\"\n            style=\"left: ${position}%;\"\n          ></div>\n        `);\n\n        // Add hour label\n        markers.push(html`\n          <div\n            key=\"label-${hour}\"\n            class=\"absolute top-0 text-xs text-gray-600 dark:text-gray-300 transform -translate-x-1/2\"\n            style=\"left: ${position}%;\"\n          >\n            ${hour}:00\n          </div>\n        `);\n\n        // Add half-hour marker if not the last hour and we're zoomed in enough\n        if (hour < 24 && zoomLevel >= 2) {\n          const halfHourPosition = ((hour + 0.5 - startHour) / (endHour - startHour)) * 100;\n          markers.push(html`\n            <div\n              key=\"tick-${hour}-30\"\n              class=\"absolute top-2 w-px h-3 bg-gray-400 dark:bg-gray-500\"\n              style=\"left: ${halfHourPosition}%;\"\n            ></div>\n          `);\n\n          // Add 15-minute markers if zoomed in even more\n          if (zoomLevel >= 4) {\n            const quarterHourPosition1 = ((hour + 0.25 - startHour) / (endHour - startHour)) * 100;\n            const quarterHourPosition3 = ((hour + 0.75 - startHour) / (endHour - startHour)) * 100;\n\n            markers.push(html`\n              <div\n                key=\"tick-${hour}-15\"\n                class=\"absolute top-3 w-px h-2 bg-gray-400 dark:bg-gray-500\"\n                style=\"left: ${quarterHourPosition1}%;\"\n              ></div>\n            `);\n\n            markers.push(html`\n              <div\n                key=\"tick-${hour}-45\"\n                class=\"absolute top-3 w-px h-2 bg-gray-400 dark:bg-gray-500\"\n                style=\"left: ${quarterHourPosition3}%;\"\n              ></div>\n            `);\n          }\n        }\n      }\n    }\n\n    return markers;\n  };\n\n  return html`\n    <div class=\"timeline-ruler relative w-full h-8 bg-gray-300 dark:bg-gray-800 border-b border-gray-400 dark:border-gray-600\">\n      ${generateHourMarkers()}\n      <div class=\"absolute bottom-0 left-0 text-xs text-gray-500 px-1\">\n        Zoom: ${zoomLevel}x (${Math.round(24 / zoomLevel)} hours)\n      </div>\n    </div>\n  `;\n}\n","/**\n * LightNVR Timeline Segments Component\n * Displays recording segments on the timeline\n */\n\nimport { html } from '../../../html-helper.js';\nimport { useState, useEffect, useRef } from 'preact/hooks';\nimport { timelineState } from './TimelinePage.js';\n\n/**\n * TimelineSegments component\n * @param {Object} props Component props\n * @param {Array} props.segments Array of timeline segments\n * @returns {JSX.Element} TimelineSegments component\n */\nexport function TimelineSegments({ segments: propSegments }) {\n  // Local state\n  const [segments, setSegments] = useState(propSegments || []);\n  const [startHour, setStartHour] = useState(0);\n  const [endHour, setEndHour] = useState(24);\n  const [currentSegmentIndex, setCurrentSegmentIndex] = useState(-1);\n\n  // Update segments when props change\n  useEffect(() => {\n    console.log(`TimelineSegments: Received segments from props: ${propSegments ? propSegments.length : 0}`);\n    if (propSegments && propSegments.length > 0) {\n      setSegments(propSegments);\n    }\n  }, [propSegments]);\n\n  // Refs\n  const containerRef = useRef(null);\n  const isDragging = useRef(false);\n\n  // Track the last time segments were updated to prevent too frequent updates\n  const lastSegmentsUpdateRef = useRef(0);\n  const lastSegmentsRef = useRef([]);\n\n  // Subscribe to timeline state changes\n  useEffect(() => {\n    const unsubscribe = timelineState.subscribe(state => {\n      console.log(`TimelineSegments: State update received, segments: ${state.timelineSegments ? state.timelineSegments.length : 0}`);\n\n      // Always update segments when they change\n      if (state.timelineSegments) {\n        // Check if segments have changed\n        const segmentsChanged = !lastSegmentsRef.current ||\n                               state.timelineSegments.length !== lastSegmentsRef.current.length ||\n                               JSON.stringify(state.timelineSegments) !== JSON.stringify(lastSegmentsRef.current) ||\n                               state.forceReload;\n\n        if (segmentsChanged) {\n          console.log(`TimelineSegments: Updating segments (${state.timelineSegments.length})`);\n          setSegments(state.timelineSegments);\n          lastSegmentsRef.current = [...state.timelineSegments]; // Create a copy\n          lastSegmentsUpdateRef.current = Date.now();\n        }\n      }\n\n      // Always update these lightweight properties\n      const newStartHour = state.timelineStartHour !== undefined ? state.timelineStartHour : 0;\n      const newEndHour = state.timelineEndHour !== undefined ? state.timelineEndHour : 24;\n\n      console.log(`TimelineSegments: Time range update - startHour: ${newStartHour}, endHour: ${newEndHour}`);\n\n      setStartHour(newStartHour);\n      setEndHour(newEndHour);\n      setCurrentSegmentIndex(state.currentSegmentIndex || -1);\n    });\n\n    // Initial load of segments\n    if (timelineState.timelineSegments && timelineState.timelineSegments.length > 0) {\n      console.log(`TimelineSegments: Initial load of segments (${timelineState.timelineSegments.length})`);\n      setSegments(timelineState.timelineSegments);\n      lastSegmentsRef.current = [...timelineState.timelineSegments];\n      setCurrentSegmentIndex(timelineState.currentSegmentIndex || 0);\n\n      // Also set the time range\n      if (timelineState.timelineStartHour !== undefined) {\n        setStartHour(timelineState.timelineStartHour);\n      }\n      if (timelineState.timelineEndHour !== undefined) {\n        setEndHour(timelineState.timelineEndHour);\n      }\n\n      lastSegmentsUpdateRef.current = Date.now();\n    }\n\n    return () => unsubscribe();\n  }, []);\n\n  // Set up drag handling\n  useEffect(() => {\n    const container = containerRef.current;\n    if (!container) return;\n\n    const handleMouseDown = (e) => {\n      // Only handle clicks on the container itself, not on segments\n      if (e.target === container || e.target.classList.contains('timeline-clickable-area')) {\n        isDragging.current = true;\n        handleTimelineClick(e);\n\n        // Add event listeners for drag\n        document.addEventListener('mousemove', handleMouseMove);\n        document.addEventListener('mouseup', handleMouseUp);\n      }\n    };\n\n    const handleMouseMove = (e) => {\n      if (!isDragging.current) return;\n      handleTimelineClick(e);\n    };\n\n    const handleMouseUp = () => {\n      isDragging.current = false;\n      document.removeEventListener('mousemove', handleMouseMove);\n      document.removeEventListener('mouseup', handleMouseUp);\n    };\n\n    container.addEventListener('mousedown', handleMouseDown);\n\n    return () => {\n      container.removeEventListener('mousedown', handleMouseDown);\n      document.removeEventListener('mousemove', handleMouseMove);\n      document.removeEventListener('mouseup', handleMouseUp);\n    };\n  }, [startHour, endHour, segments]);\n\n  // Handle click on timeline for seeking\n  const handleTimelineClick = (event) => {\n    const container = containerRef.current;\n    if (!container) return;\n\n    // Get click position relative to container\n    const rect = container.getBoundingClientRect();\n    const clickX = event.clientX - rect.left;\n    const containerWidth = rect.width;\n\n    // Calculate time based on click position\n    const clickPercent = clickX / containerWidth;\n    const clickHour = startHour + (clickPercent * (endHour - startHour));\n\n    // Find the segment that contains this time\n    const clickDate = new Date(timelineState.selectedDate);\n    clickDate.setHours(Math.floor(clickHour));\n    clickDate.setMinutes(Math.floor((clickHour % 1) * 60));\n    clickDate.setSeconds(Math.floor(((clickHour % 1) * 60) % 1 * 60));\n\n    const clickTimestamp = clickDate.getTime() / 1000;\n\n    // Always update the current time to where the user clicked\n    // This allows the user to position the cursor anywhere on the timeline\n    timelineState.setState({\n      currentTime: clickTimestamp,\n      prevCurrentTime: timelineState.currentTime,\n      // Don't automatically start playing\n      isPlaying: false\n    });\n\n    // Find segment that contains this timestamp\n    let foundSegment = false;\n    for (let i = 0; i < segments.length; i++) {\n      const segment = segments[i];\n      // Use local timestamps if available, otherwise fall back to regular timestamps\n      const startTimestamp = segment.local_start_timestamp || segment.start_timestamp;\n      const endTimestamp = segment.local_end_timestamp || segment.end_timestamp;\n\n      if (clickTimestamp >= startTimestamp && clickTimestamp <= endTimestamp) {\n        console.log(`TimelineSegments: Found segment ${i} containing timestamp`);\n\n        // Update current segment index without starting playback\n        timelineState.setState({\n          currentSegmentIndex: i\n        });\n\n        // Only if the user clicked directly on a segment (not the background),\n        // play that segment starting at the clicked time\n        if (event.target.classList.contains('timeline-segment')) {\n          // Calculate relative time within the segment\n          const relativeTime = clickTimestamp - startTimestamp;\n\n          // Play this segment starting at the clicked time\n          playSegment(i, relativeTime);\n        }\n\n        foundSegment = true;\n        break;\n      }\n    }\n\n    if (!foundSegment) {\n      // If no segment found, don't automatically jump to a different segment\n      // Just leave the cursor where the user clicked\n      timelineState.setState({\n        currentSegmentIndex: -1\n      });\n    }\n  };\n\n  // Play a specific segment\n  const playSegment = (index, relativeTime = null) => {\n    console.log(`TimelineSegments: playSegment(${index}, ${relativeTime})`);\n\n    if (index < 0 || index >= segments.length) {\n      console.warn(`TimelineSegments: Invalid segment index: ${index}`);\n      return;\n    }\n\n    const segment = segments[index];\n\n    // Use local timestamps if available, otherwise fall back to regular timestamps\n    const startTimestamp = segment.local_start_timestamp || segment.start_timestamp;\n\n    // Calculate absolute timestamp for currentTime\n    const absoluteTime = relativeTime !== null\n      ? startTimestamp + relativeTime\n      : startTimestamp;\n\n    // First, pause any current playback and reset the segment index\n    timelineState.setState({\n      isPlaying: false,\n      currentSegmentIndex: -1\n    });\n\n    // Force a synchronous DOM update\n    document.body.offsetHeight;\n\n    // Now set the new segment index and start playing\n    setTimeout(() => {\n      timelineState.setState({\n        currentSegmentIndex: index,\n        currentTime: absoluteTime,\n        isPlaying: true,\n        forceReload: true\n      });\n\n      // Force the video player to reload\n      setTimeout(() => {\n        const videoElement = document.querySelector('#video-player video');\n        if (videoElement) {\n          // Pause any current playback\n          videoElement.pause();\n\n          // Clear the source and reload\n          videoElement.removeAttribute('src');\n          videoElement.load();\n\n          // Set the new source\n          videoElement.src = `/api/recordings/play/${segment.id}?t=${Date.now()}`;\n\n          // Set the current time and play\n          videoElement.onloadedmetadata = () => {\n            const seekTime = relativeTime !== null ? relativeTime : 0;\n            videoElement.currentTime = seekTime;\n            videoElement.play().catch(e => console.error('Error playing video:', e));\n          };\n        }\n      }, 50);\n    }, 50);\n  };\n\n  // Render segments\n  const renderSegments = () => {\n    console.log('TimelineSegments: renderSegments called');\n    console.log('TimelineSegments: segments:', segments);\n    console.log('TimelineSegments: startHour:', startHour, 'endHour:', endHour);\n\n    if (!segments || segments.length === 0) {\n      console.log('TimelineSegments: No segments to render');\n      return html`<div class=\"text-center text-red-500 font-bold\">No segments to display</div>`;\n    }\n\n    console.log('TimelineSegments: Rendering segments:', segments.length);\n\n    const visibleSegments = [];\n    const hourMap = new Map();\n\n    // First pass: collect all segments by hour\n    console.log('TimelineSegments: Starting to process segments');\n    let visibleCount = 0;\n    let skippedCount = 0;\n\n    segments.forEach((segment, index) => {\n      // Always use regular timestamps for consistency\n      const startTimestamp = segment.start_timestamp;\n      const endTimestamp = segment.end_timestamp;\n\n      // Convert timestamps to Date objects\n      const startTime = new Date(startTimestamp * 1000);\n      const endTime = new Date(endTimestamp * 1000);\n\n      // Calculate position and width\n      const startHourFloat = startTime.getHours() + (startTime.getMinutes() / 60) + (startTime.getSeconds() / 3600);\n      const endHourFloat = endTime.getHours() + (endTime.getMinutes() / 60) + (endTime.getSeconds() / 3600);\n\n      // Skip segments outside the visible range\n      if (endHourFloat < startHour || startHourFloat > endHour) {\n        skippedCount++;\n        if (index < 5) {\n          console.log(`TimelineSegments: Skipping segment ${index}, startHour=${startHourFloat}, endHour=${endHourFloat}, visible range=${startHour}-${endHour}`);\n        }\n        return;\n      }\n      visibleCount++;\n\n      // Mark each hour that this segment spans\n      const startFloorHour = Math.floor(startHourFloat);\n      const endCeilHour = Math.min(Math.ceil(endHourFloat), 24);\n\n      for (let h = startFloorHour; h < endCeilHour; h++) {\n        if (h >= startHour && h <= endHour) {\n          if (!hourMap.has(h)) {\n            hourMap.set(h, []);\n          }\n          hourMap.get(h).push(index);\n        }\n      }\n    });\n\n    // Preprocess segments to merge adjacent ones\n    const mergedSegments = [];\n    let currentMergedSegment = null;\n\n    // Sort segments by start time\n    const sortedSegments = [...segments].sort((a, b) => {\n      return a.start_timestamp - b.start_timestamp;\n    });\n\n    // Merge adjacent segments (no gap or very small gap)\n    sortedSegments.forEach((segment, index) => {\n      if (!currentMergedSegment) {\n        // First segment\n        currentMergedSegment = { ...segment, originalIndices: [index] };\n      } else {\n        // Check if this segment is adjacent to the current merged segment\n        const segmentStart = segment.start_timestamp;\n        const mergedEnd = currentMergedSegment.end_timestamp;\n\n        // Allow a small gap (1 second) to account for rounding errors\n        const gap = segmentStart - mergedEnd;\n\n        if (gap <= 1) {\n          // Merge with current segment\n          currentMergedSegment.end_timestamp = segment.end_timestamp;\n          currentMergedSegment.originalIndices.push(index);\n\n          // If this segment has detection, mark the merged segment as having detection\n          if (segment.has_detection) {\n            currentMergedSegment.has_detection = true;\n          }\n        } else {\n          // Gap is too large, start a new merged segment\n          mergedSegments.push(currentMergedSegment);\n          currentMergedSegment = { ...segment, originalIndices: [index] };\n        }\n      }\n    });\n\n    // Add the last merged segment\n    if (currentMergedSegment) {\n      mergedSegments.push(currentMergedSegment);\n    }\n\n    // Second pass: add visible segments\n    mergedSegments.forEach((segment, mergedIndex) => {\n      const segStartTimestamp = segment.start_timestamp;\n      const segEndTimestamp = segment.end_timestamp;\n\n      // Convert timestamps to Date objects\n      const startTime = new Date(segStartTimestamp * 1000);\n      const endTime = new Date(segEndTimestamp * 1000);\n\n      // Calculate position and width\n      const startHourFloat = startTime.getHours() + (startTime.getMinutes() / 60) + (startTime.getSeconds() / 3600);\n      const endHourFloat = endTime.getHours() + (endTime.getMinutes() / 60) + (endTime.getSeconds() / 3600);\n\n      // Skip segments outside the visible range\n      if (endHourFloat < startHour || startHourFloat > endHour) {\n        return;\n      }\n\n      // Adjust start and end to fit within visible range\n      const visibleStartHour = Math.max(startHourFloat, startHour);\n      const visibleEndHour = Math.min(endHourFloat, endHour);\n\n      // Calculate position and width as percentages\n      const startPercent = ((visibleStartHour - startHour) / (endHour - startHour)) * 100;\n      const widthPercent = ((visibleEndHour - visibleStartHour) / (endHour - startHour)) * 100;\n\n      // Format duration for tooltip\n      const duration = Math.round(segEndTimestamp - segStartTimestamp);\n      const durationStr = `${duration}s`;\n\n      // Format times for tooltip\n      const startTimeStr = startTime.toLocaleTimeString();\n      const endTimeStr = endTime.toLocaleTimeString();\n\n      // Use a consistent height for all segments\n      const heightPercent = 80; // 80% height for all segments\n\n      visibleSegments.push(html`\n        <div\n          key=\"segment-${mergedIndex}\"\n          class=\"timeline-segment absolute rounded-sm transition-all duration-200 ${segment.has_detection ? 'bg-red-500' : 'bg-blue-500'}\"\n          style=\"left: ${startPercent}%; width: ${widthPercent}%; height: ${heightPercent}%; top: 50%; transform: translateY(-50%);\"\n          title=\"${startTimeStr} - ${endTimeStr} (${durationStr})\"\n        ></div>\n      `);\n    });\n\n    // Third pass: fill in gaps with clickable areas\n    for (let hour = Math.floor(startHour); hour < Math.ceil(endHour); hour++) {\n      if (!hourMap.has(hour)) {\n        // No segments in this hour, create a clickable area\n        const position = ((hour - startHour) / (endHour - startHour)) * 100;\n        const width = 100 / (endHour - startHour);\n\n        visibleSegments.push(html`\n          <div\n            key=\"clickable-${hour}\"\n            class=\"timeline-clickable-area absolute h-full cursor-pointer\"\n            style=\"left: ${position}%; width: ${width}%;\"\n            data-hour=${hour}\n          ></div>\n        `);\n      }\n    }\n\n    console.log(`TimelineSegments: Rendering complete. Total: ${segments.length}, Visible: ${visibleCount}, Skipped: ${skippedCount}, Final rendered: ${visibleSegments.length}`);\n    return visibleSegments;\n  };\n\n  return html`\n    <div\n      class=\"timeline-segments relative w-full h-16 pt-2\"\n      ref=${containerRef}\n    >\n      ${renderSegments()}\n    </div>\n  `;\n}\n","/**\n * LightNVR Timeline Cursor Component\n * Displays the playback cursor on the timeline\n */\n\n\nimport { html } from '../../../html-helper.js';\nimport { useState, useEffect, useRef } from 'preact/hooks';\nimport { timelineState } from './TimelinePage.js';\n\n/**\n * TimelineCursor component\n * @returns {JSX.Element} TimelineCursor component\n */\nexport function TimelineCursor() {\n  // Local state\n  const [position, setPosition] = useState(0);\n  const [visible, setVisible] = useState(false);\n  const [startHour, setStartHour] = useState(0);\n  const [endHour, setEndHour] = useState(24);\n  const [currentTime, setCurrentTime] = useState(null);\n  const [isDragging, setIsDragging] = useState(false);\n\n  // Refs\n  const cursorRef = useRef(null);\n  const containerRef = useRef(null);\n  const dragStartXRef = useRef(0);\n\n  // Debounce function to limit how often a function can be called\n  const debounce = (func, delay) => {\n    let timeoutId;\n    return function(...args) {\n      if (timeoutId) {\n        clearTimeout(timeoutId);\n      }\n      timeoutId = setTimeout(() => {\n        func.apply(this, args);\n      }, delay);\n    };\n  };\n\n  // Create debounced version of updateCursorPosition\n  const debouncedUpdateCursorPosition = useRef(\n    debounce((time, startHr, endHr) => {\n      updateCursorPosition(time, startHr, endHr);\n    }, 100)\n  ).current;\n\n  // Subscribe to timeline state changes\n  useEffect(() => {\n    const unsubscribe = timelineState.subscribe(state => {\n      console.log('TimelineCursor: State update received', {\n        currentTime: state.currentTime,\n        startHour: state.timelineStartHour,\n        endHour: state.timelineEndHour,\n        segmentsCount: state.timelineSegments ? state.timelineSegments.length : 0,\n        isDragging: isDragging,\n        userControllingCursor: state.userControllingCursor\n      });\n\n      // Update local state\n      setStartHour(state.timelineStartHour || 0);\n      setEndHour(state.timelineEndHour || 24);\n\n      // Only update current time if not dragging\n      if (!isDragging && !state.userControllingCursor) {\n        setCurrentTime(state.currentTime);\n        updateTimeDisplay(state.currentTime);\n\n        // Use debounced update for smoother performance\n        debouncedUpdateCursorPosition(state.currentTime, state.timelineStartHour || 0, state.timelineEndHour || 24);\n      }\n    });\n\n    return () => unsubscribe();\n  }, [isDragging, debouncedUpdateCursorPosition]);\n\n  // Set up drag handling\n  useEffect(() => {\n    const cursor = cursorRef.current;\n    if (!cursor) return;\n\n    const handleMouseDown = (e) => {\n      e.preventDefault();\n      e.stopPropagation();\n\n      console.log('TimelineCursor: Mouse down event');\n\n      // Store the starting X position\n      dragStartXRef.current = e.clientX;\n\n      // Set dragging state\n      setIsDragging(true);\n\n      // Set global flag to prevent other components from updating cursor\n      timelineState.userControllingCursor = true;\n      timelineState.setState({});\n\n      // Add event listeners for drag\n      document.addEventListener('mousemove', handleMouseMove);\n      document.addEventListener('mouseup', handleMouseUp);\n    };\n\n    const handleMouseMove = (e) => {\n      if (!isDragging) return;\n\n      // Get container dimensions\n      const container = cursor.parentElement;\n      if (!container) return;\n\n      const rect = container.getBoundingClientRect();\n      const clickX = Math.max(0, Math.min(e.clientX - rect.left, rect.width));\n      const containerWidth = rect.width;\n\n      // Calculate position as percentage\n      const positionPercent = (clickX / containerWidth) * 100;\n      setPosition(positionPercent);\n\n      // Calculate time based on position\n      const hourRange = endHour - startHour;\n      const hour = startHour + (positionPercent / 100) * hourRange;\n\n      // Convert hour to timestamp\n      const date = new Date();\n      if (timelineState.selectedDate) {\n        date.setTime(new Date(timelineState.selectedDate).getTime());\n      }\n      date.setHours(Math.floor(hour));\n      date.setMinutes(Math.floor((hour % 1) * 60));\n      date.setSeconds(Math.floor(((hour % 1) * 60) % 1 * 60));\n      date.setMilliseconds(0);\n\n      const timestamp = date.getTime() / 1000;\n\n      // Store the current time locally but don't update the global state yet\n      setCurrentTime(timestamp);\n\n      // Update time display\n      updateTimeDisplay(timestamp);\n    };\n\n    const handleMouseUp = (e) => {\n      if (!isDragging) return;\n\n      // Get container dimensions\n      const container = cursor.parentElement;\n      if (!container) return;\n\n      const rect = container.getBoundingClientRect();\n      const clickX = Math.max(0, Math.min(e.clientX - rect.left, rect.width));\n      const containerWidth = rect.width;\n\n      // Calculate position as percentage\n      const positionPercent = (clickX / containerWidth) * 100;\n      console.log('TimelineCursor: Mouse up at position', { positionPercent, clickX, containerWidth });\n\n      // Calculate time based on position\n      const hourRange = endHour - startHour;\n      const hour = startHour + (positionPercent / 100) * hourRange;\n      console.log('TimelineCursor: Calculated hour', { hour, startHour, endHour, hourRange });\n\n      // Convert hour to timestamp\n      const date = new Date();\n      if (timelineState.selectedDate) {\n        date.setTime(new Date(timelineState.selectedDate).getTime());\n      }\n      date.setHours(Math.floor(hour));\n      date.setMinutes(Math.floor((hour % 1) * 60));\n      date.setSeconds(Math.floor(((hour % 1) * 60) % 1 * 60));\n      date.setMilliseconds(0);\n\n      const timestamp = date.getTime() / 1000;\n      console.log('TimelineCursor: Converted to timestamp', {\n        timestamp,\n        dateTime: date.toLocaleString(),\n        selectedDate: timelineState.selectedDate\n      });\n\n      console.log('TimelineCursor: Mouse up event');\n\n      // Reset dragging state FIRST\n      setIsDragging(false);\n\n      // Remove event listeners\n      document.removeEventListener('mousemove', handleMouseMove);\n      document.removeEventListener('mouseup', handleMouseUp);\n\n      // Reset the user controlling cursor flag AFTER a short delay\n      // This allows the current update to complete before other components can update the cursor\n      setTimeout(() => {\n        console.log('TimelineCursor: Releasing cursor control');\n        timelineState.userControllingCursor = false;\n        timelineState.setState({});\n      }, 100);\n\n      // Always update the current time to where the user placed the cursor\n      // This allows the user to position the cursor anywhere on the timeline\n      timelineState.currentTime = timestamp;\n      timelineState.prevCurrentTime = timelineState.currentTime;\n      timelineState.isPlaying = false;\n\n      // Notify listeners\n      timelineState.setState({});\n\n      // Find segment that contains this timestamp\n      const segments = timelineState.timelineSegments || [];\n      console.log('TimelineCursor: Searching for segment containing timestamp', {\n        timestamp,\n        segmentsCount: segments.length\n      });\n\n      let foundSegment = false;\n      let closestSegment = -1;\n      let minDistance = Infinity;\n\n      // First try to find an exact match\n      for (let i = 0; i < segments.length; i++) {\n        const segment = segments[i];\n        // Use local timestamps if available, otherwise fall back to regular timestamps\n        const startTimestamp = segment.local_start_timestamp || segment.start_timestamp;\n        const endTimestamp = segment.local_end_timestamp || segment.end_timestamp;\n\n        // Log the first few segments for debugging\n        if (i < 3) {\n          console.log(`TimelineCursor: Segment ${i}`, {\n            startTimestamp,\n            endTimestamp,\n            startTime: new Date(startTimestamp * 1000).toLocaleTimeString(),\n            endTime: new Date(endTimestamp * 1000).toLocaleTimeString()\n          });\n        }\n\n        // Check if timestamp is within this segment\n        if (timestamp >= startTimestamp && timestamp <= endTimestamp) {\n          console.log(`TimelineCursor: Found exact match at segment ${i}`);\n          // Update current segment index without changing the time or starting playback\n          timelineState.currentSegmentIndex = i;\n          timelineState.setState({});\n          foundSegment = true;\n          break;\n        }\n\n        // Calculate distance to this segment (for finding closest if no exact match)\n        const midpoint = (startTimestamp + endTimestamp) / 2;\n        const distance = Math.abs(timestamp - midpoint);\n        if (distance < minDistance) {\n          minDistance = distance;\n          closestSegment = i;\n        }\n      }\n\n      // If no exact match found, use the closest segment\n      if (!foundSegment) {\n        if (closestSegment >= 0) {\n          console.log(`TimelineCursor: No exact match, using closest segment ${closestSegment}`);\n          timelineState.currentSegmentIndex = closestSegment;\n          timelineState.setState({});\n        } else {\n          console.log('TimelineCursor: No segments found at all');\n          // Reset current segment index\n          timelineState.currentSegmentIndex = -1;\n          timelineState.setState({});\n        }\n      }\n    };\n\n    // Add event listeners\n    cursor.addEventListener('mousedown', handleMouseDown);\n\n    return () => {\n      cursor.removeEventListener('mousedown', handleMouseDown);\n      document.removeEventListener('mousemove', handleMouseMove);\n      document.removeEventListener('mouseup', handleMouseUp);\n    };\n  }, [cursorRef.current, startHour, endHour, isDragging]);\n\n  // Update cursor position\n  const updateCursorPosition = (time, startHr, endHr) => {\n    console.log('TimelineCursor: updateCursorPosition called', { time, startHr, endHr });\n\n    if (time === null) {\n      console.log('TimelineCursor: No current time, hiding cursor');\n      setVisible(false);\n      return;\n    }\n\n    // Calculate cursor position\n    const date = new Date(time * 1000);\n    const hour = date.getHours() + (date.getMinutes() / 60) + (date.getSeconds() / 3600);\n    console.log('TimelineCursor: Calculated hour', { hour, timeString: date.toLocaleTimeString() });\n\n    // Check if the current time is within the visible range\n    if (hour < startHr || hour > endHr) {\n      console.log('TimelineCursor: Time outside visible range, hiding cursor');\n      setVisible(false);\n      return;\n    }\n\n    // Calculate position as percentage\n    const position = ((hour - startHr) / (endHr - startHr)) * 100;\n    console.log('TimelineCursor: Calculated position', { position, hour, startHr, endHr });\n\n    // Update cursor position\n    setPosition(position);\n    setVisible(true);\n  };\n\n  // Update time display\n  const updateTimeDisplay = (time) => {\n    if (time === null) return;\n\n    const timeDisplay = document.getElementById('time-display');\n    if (!timeDisplay) return;\n\n    const date = new Date(time * 1000);\n\n    // Format date and time\n    const hours = date.getHours().toString().padStart(2, '0');\n    const minutes = date.getMinutes().toString().padStart(2, '0');\n    const seconds = date.getSeconds().toString().padStart(2, '0');\n\n    // Display time only (HH:MM:SS)\n    timeDisplay.textContent = `${hours}:${minutes}:${seconds}`;\n  };\n\n  // Force the cursor to be visible on initial render\n  useEffect(() => {\n    console.log('TimelineCursor: Initializing cursor position');\n    console.log('TimelineCursor: Initial state', {\n      currentTime: timelineState.currentTime,\n      startHour: timelineState.timelineStartHour,\n      endHour: timelineState.timelineEndHour,\n      segments: timelineState.timelineSegments ? timelineState.timelineSegments.length : 0\n    });\n\n    // Function to initialize cursor\n    const initCursor = () => {\n      console.log('TimelineCursor: Checking timelineState directly', {\n        currentTime: timelineState.currentTime,\n        segmentsLength: timelineState.timelineSegments ? timelineState.timelineSegments.length : 0,\n        currentSegmentIndex: timelineState.currentSegmentIndex\n      });\n\n      if (timelineState.currentTime) {\n        console.log('TimelineCursor: Setting initial cursor position with current time');\n        setVisible(true);\n        updateCursorPosition(\n          timelineState.currentTime,\n          timelineState.timelineStartHour || 0,\n          timelineState.timelineEndHour || 24\n        );\n        return true;\n      } else if (timelineState.timelineSegments && timelineState.timelineSegments.length > 0) {\n        // If no current time but we have segments, use the first segment's start time\n        console.log('TimelineCursor: Using first segment start time for cursor');\n        const firstSegment = timelineState.timelineSegments[0];\n        const startTime = firstSegment.start_timestamp;\n\n        // Update the timeline state with this time - DIRECT ASSIGNMENT\n        console.log('TimelineCursor: Directly setting timelineState properties');\n        timelineState.currentTime = startTime;\n        timelineState.currentSegmentIndex = 0;\n\n        // Now call setState to notify listeners\n        timelineState.setState({\n          // Empty object just to trigger notification\n        });\n\n        setVisible(true);\n        updateCursorPosition(\n          startTime,\n          timelineState.timelineStartHour || 0,\n          timelineState.timelineEndHour || 24\n        );\n        return true;\n      }\n      return false;\n    };\n\n    // Try to initialize immediately\n    const initialized = initCursor();\n\n    // If not initialized, try again after a delay\n    if (!initialized) {\n      console.log('TimelineCursor: Initial initialization failed, will retry after delay');\n\n      // Set up multiple attempts with increasing delays\n      const delays = [100, 300, 500, 1000];\n\n      delays.forEach((delay, index) => {\n        setTimeout(() => {\n          if (!visible) {\n            console.log(`TimelineCursor: Retry initialization attempt ${index + 1}`);\n            initCursor();\n          }\n        }, delay);\n      });\n    }\n  }, []);\n\n  return html`\n    <div\n      ref=${cursorRef}\n      class=\"timeline-cursor absolute top-0 h-full z-50 transition-all duration-100 cursor-ew-resize\"\n      style=\"left: ${position}%; display: ${visible ? 'block' : 'none'}; pointer-events: auto; width: 7px; margin-left: -3.5px;\"\n    >\n      <!-- Invisible wider clickable area -->\n      <div class=\"absolute top-0 bottom-0 left-0 w-full\"></div>\n\n      <!-- Skinnier needle with no middle chunk -->\n      <div class=\"absolute top-0 bottom-0 w-0.5 bg-orange-500 left-1/2 transform -translate-x-1/2 pointer-events-none\"></div>\n\n      <!-- Top handle (black) -->\n      <div class=\"absolute top-0 left-1/2 w-4 h-4 bg-black rounded-full transform -translate-x-1/2 -translate-y-1/2 shadow-md pointer-events-none\"></div>\n\n      <!-- Bottom handle (black) -->\n      <div class=\"absolute bottom-0 left-1/2 w-4 h-4 bg-black rounded-full transform -translate-x-1/2 translate-y-1/2 shadow-md pointer-events-none\"></div>\n    </div>\n  `;\n}\n","/**\n * LightNVR Speed Controls Component\n * Handles playback speed controls for the timeline\n */\n\n\nimport { html } from '../../../html-helper.js';\nimport { useState, useEffect } from 'preact/hooks';\nimport { timelineState } from './TimelinePage.js';\nimport { showStatusMessage } from '../UI.js';\n\n/**\n * SpeedControls component\n * @returns {JSX.Element} SpeedControls component\n */\nexport function SpeedControls() {\n  // Local state\n  const [currentSpeed, setCurrentSpeed] = useState(1.0);\n  \n  // Available speeds\n  const speeds = [0.25, 0.5, 1.0, 1.5, 2.0, 4.0];\n\n  // Subscribe to timeline state changes\n  useEffect(() => {\n    const unsubscribe = timelineState.subscribe(state => {\n      setCurrentSpeed(state.playbackSpeed);\n    });\n    \n    return () => unsubscribe();\n  }, []);\n\n  // Set playback speed\n  const setPlaybackSpeed = (speed) => {\n    // Update video playback rate\n    const videoPlayer = document.querySelector('#video-player video');\n    if (videoPlayer) {\n      // Set the new playback rate\n      videoPlayer.playbackRate = speed;\n    }\n    \n    // Update timeline state\n    timelineState.setState({ playbackSpeed: speed });\n    \n    // Show status message\n    showStatusMessage(`Playback speed: ${speed}x`, 'info');\n  };\n\n  return html`\n    <div class=\"mt-2 mb-4 p-2 border border-green-500 rounded-lg bg-white dark:bg-gray-800 shadow-sm\">\n      <div class=\"flex flex-col items-center\">\n        <div class=\"text-sm font-semibold mb-2 text-gray-700 dark:text-gray-300\">Playback Speed</div>\n        \n        <div class=\"flex flex-wrap justify-center gap-1\">\n          ${speeds.map(speed => html`\n            <button \n              key=${`speed-${speed}`}\n              class=${`speed-btn px-2 py-1 text-sm rounded-full ${speed === currentSpeed \n                ? 'bg-green-500 text-white' \n                : 'bg-gray-200 hover:bg-gray-300 dark:bg-gray-700 dark:text-gray-200 dark:hover:bg-gray-600'} \n                font-medium transition-all focus:outline-none focus:ring-1 focus:ring-green-500 focus:ring-opacity-50`}\n              data-speed=${speed}\n              onClick=${() => setPlaybackSpeed(speed)}\n            >\n              ${speed === 1.0 ? '1 (Normal)' : `${speed}`}\n            </button>\n          `)}\n        </div>\n        \n        <div class=\"mt-1 text-xs font-medium text-green-600 dark:text-green-400\">\n          Current: ${currentSpeed} ${currentSpeed === 1.0 ? '(Normal)' : ''}\n        </div>\n      </div>\n    </div>\n  `;\n}\n","/**\n * LightNVR Timeline Player Component\n * Handles video playback for the timeline\n */\n\nimport { html } from '../../../html-helper.js';\nimport { useState, useEffect, useRef } from 'preact/hooks';\nimport { timelineState } from './TimelinePage.js';\nimport { SpeedControls } from './SpeedControls.js';\nimport { showStatusMessage } from '../UI.js';\n\n/**\n * TimelinePlayer component\n * @returns {JSX.Element} TimelinePlayer component\n */\nexport function TimelinePlayer() {\n  // Local state\n  const [currentSegmentIndex, setCurrentSegmentIndex] = useState(-1);\n  const [isPlaying, setIsPlaying] = useState(false);\n  const [segments, setSegments] = useState([]);\n  const [playbackSpeed, setPlaybackSpeed] = useState(1.0);\n\n  // Refs\n  const videoRef = useRef(null);\n  const lastTimeUpdateRef = useRef(null);\n  const lastSegmentIdRef = useRef(null);\n\n  // Subscribe to timeline state changes\n  useEffect(() => {\n    const unsubscribe = timelineState.subscribe(state => {\n      // Update local state\n      setCurrentSegmentIndex(state.currentSegmentIndex);\n      setIsPlaying(state.isPlaying);\n      setSegments(state.timelineSegments || []);\n      setPlaybackSpeed(state.playbackSpeed);\n\n      // Handle video playback\n      handleVideoPlayback(state);\n    });\n    \n    return () => unsubscribe();\n  }, []);\n\n  // Handle video playback based on state changes\n  const handleVideoPlayback = (state) => {\n    const video = videoRef.current;\n    if (!video) return;\n    \n    // Check if we have valid segments and segment index\n    if (!state.timelineSegments || \n        state.timelineSegments.length === 0 || \n        state.currentSegmentIndex < 0 || \n        state.currentSegmentIndex >= state.timelineSegments.length) {\n      return;\n    }\n    \n    // Get current segment\n    const segment = state.timelineSegments[state.currentSegmentIndex];\n    if (!segment) return;\n    \n    // Check if we need to load a new segment\n    const segmentChanged = lastSegmentIdRef.current !== segment.id;\n    \n    // IMPORTANT: Only reload if the segment has actually changed\n    // This prevents constant reloading\n    const needsReload = segmentChanged;\n    \n    // Calculate relative time within the segment\n    const relativeTime = state.currentTime !== null && \n                         state.currentTime >= segment.start_timestamp\n      ? state.currentTime - segment.start_timestamp\n      : 0;\n    \n    // Only update the video if:\n    // 1. We need to load a new segment, OR\n    // 2. The user is dragging the cursor (indicated by a significant time change)\n    const timeChanged = state.prevCurrentTime !== null && \n                        Math.abs(state.currentTime - state.prevCurrentTime) > 1;\n    \n    // Update last segment ID\n    if (segmentChanged) {\n      console.log(`Segment changed from ${lastSegmentIdRef.current} to ${segment.id}`);\n      lastSegmentIdRef.current = segment.id;\n    }\n    \n    // Handle playback\n    if (needsReload) {\n      // Load new segment\n      console.log(`Loading new segment ${segment.id} (segmentChanged: ${segmentChanged})`);\n      loadSegment(segment, relativeTime, state.isPlaying);\n    } else if (timeChanged) {\n      // User is dragging the cursor, just update the current time\n      console.log(`Seeking to ${relativeTime}s within current segment`);\n      video.currentTime = relativeTime;\n    } else if (state.isPlaying && video.paused) {\n      // Resume playback if needed\n      video.play().catch(error => {\n        console.error('Error playing video:', error);\n      });\n    } else if (!state.isPlaying && !video.paused) {\n      // Pause playback if needed\n      video.pause();\n    }\n    \n    // Update playback speed if needed\n    if (video.playbackRate !== state.playbackSpeed) {\n      video.playbackRate = state.playbackSpeed;\n    }\n  };\n\n  // Load a segment\n  const loadSegment = (segment, seekTime = 0, autoplay = false) => {\n    const video = videoRef.current;\n    if (!video) return;\n    \n    console.log(`Loading segment ${segment.id} at time ${seekTime}s, autoplay: ${autoplay}`);\n    \n    // Pause current playback\n    video.pause();\n    \n    // Set new source with timestamp to prevent caching\n    const recordingUrl = `/api/recordings/play/${segment.id}?t=${Date.now()}`;\n    \n    // Set up event listeners for the new video\n    const onLoadedMetadata = () => {\n      console.log('Video metadata loaded');\n      \n      // Set current time\n      video.currentTime = seekTime;\n      \n      // Set playback speed\n      video.playbackRate = playbackSpeed;\n      \n      // Play if needed\n      if (autoplay) {\n        video.play().catch(error => {\n          console.error('Error playing video:', error);\n          showStatusMessage('Error playing video: ' + error.message, 'error');\n        });\n      }\n      \n      // Remove event listener\n      video.removeEventListener('loadedmetadata', onLoadedMetadata);\n    };\n    \n    // Add event listener for metadata loaded\n    video.addEventListener('loadedmetadata', onLoadedMetadata);\n    \n    // Set new source\n    video.src = recordingUrl;\n    video.load();\n  };\n\n  // Handle video ended event\n  const handleEnded = () => {\n    console.log('Video ended');\n    \n    // Check if we have a next segment\n    if (currentSegmentIndex < segments.length - 1) {\n      // Play next segment\n      const nextIndex = currentSegmentIndex + 1;\n      console.log(`Playing next segment ${nextIndex}`);\n      \n      // Update timeline state\n      timelineState.setState({\n        currentSegmentIndex: nextIndex,\n        currentTime: segments[nextIndex].start_timestamp,\n        isPlaying: true,\n        forceReload: true\n      });\n    } else {\n      // End of all segments\n      console.log('End of all segments');\n      \n      // Update timeline state\n      timelineState.setState({\n        isPlaying: false\n      });\n    }\n  };\n\n  // Handle video time update event\n  const handleTimeUpdate = () => {\n    const video = videoRef.current;\n    if (!video) return;\n    \n    // Check if we have a valid segment\n    if (currentSegmentIndex < 0 || \n        !segments || \n        segments.length === 0 || \n        currentSegmentIndex >= segments.length) {\n      return;\n    }\n    \n    const segment = segments[currentSegmentIndex];\n    if (!segment) return;\n    \n    // Calculate current timestamp\n    const currentTime = segment.start_timestamp + video.currentTime;\n    \n    // Directly update the time display as well\n    updateTimeDisplay(currentTime);\n    \n    // Update timeline state with the current time\n    timelineState.setState({\n      currentTime: currentTime,\n      prevCurrentTime: lastTimeUpdateRef.current\n    });\n    \n    // Update last time update\n    lastTimeUpdateRef.current = currentTime;\n  };\n\n  // Add a direct time display update function\n  const updateTimeDisplay = (time) => {\n    if (time === null) return;\n    \n    const timeDisplay = document.getElementById('time-display');\n    if (!timeDisplay) return;\n    \n    const date = new Date(time * 1000);\n    \n    // Format date and time\n    const hours = date.getHours().toString().padStart(2, '0');\n    const minutes = date.getMinutes().toString().padStart(2, '0');\n    const seconds = date.getSeconds().toString().padStart(2, '0');\n    \n    // Display time only (HH:MM:SS)\n    timeDisplay.textContent = `${hours}:${minutes}:${seconds}`;\n  };\n\n  return html`\n    <div class=\"timeline-player-container mb-2\" id=\"video-player\">\n      <div class=\"relative w-full bg-black rounded-lg shadow-md\" style=\"aspect-ratio: 16/9;\">\n        <video\n            ref=${videoRef}\n            class=\"w-full h-full object-contain\"\n            controls\n            autoplay=${false}\n            muted=${false}\n            playsInline\n            onended=${handleEnded}\n            ontimeupdate=${handleTimeUpdate}\n        ></video>\n        \n        <!-- Add a message for invalid segments -->\n        <div \n          class=\"absolute inset-0 flex items-center justify-center bg-black bg-opacity-70 text-white text-center p-4 ${currentSegmentIndex >= 0 && segments.length > 0 ? 'hidden' : ''}\"\n        >\n          <div>\n            <p class=\"mb-2\">No valid segment selected.</p>\n            <p class=\"text-sm\">Click on a segment in the timeline or use the play button to start playback.</p>\n          </div>\n        </div>\n      </div>\n    </div>\n\n    <!-- Playback speed controls -->\n    <${SpeedControls} />\n  `;\n}\n","/**\n * LightNVR Timeline View Component\n * Loads the Timeline page component into the main content area\n */\n\nimport { render } from 'preact';\nimport { html } from '../../../html-helper.js';\nimport { TimelinePage } from './TimelinePage.js';\nimport { QueryClientProvider, queryClient } from '../../../query-client.js';\n\n/**\n * Load TimelineView component\n */\nexport function loadTimelineView() {\n  const mainContent = document.getElementById('main-content');\n  if (!mainContent) return;\n\n  // Clear any existing content\n  mainContent.innerHTML = '';\n\n  // Render the TimelinePage component to the container wrapped with QueryClientProvider\n  render(\n    html`<${QueryClientProvider} client=${queryClient}>\n      <${TimelinePage} />\n    <//>`,\n    mainContent\n  );\n}","/**\n * LightNVR Timeline Page Component\n * Main component for the timeline view\n */\n\n\nimport { html } from '../../../html-helper.js';\nimport { useState, useEffect, useRef } from 'preact/hooks';\nimport { TimelineControls } from './TimelineControls.js';\nimport { TimelineRuler } from './TimelineRuler.js';\nimport { TimelineSegments } from './TimelineSegments.js';\nimport { TimelineCursor } from './TimelineCursor.js';\nimport { TimelinePlayer } from './TimelinePlayer.js';\nimport { SpeedControls } from './SpeedControls.js';\nimport { showStatusMessage } from '../UI.js';\nimport { LoadingIndicator } from '../LoadingIndicator.js';\nimport { useQuery } from '../../../query-client.js';\n\n// Global timeline state for child components\nconst timelineState = {\n  streams: [],\n  timelineSegments: [],\n  selectedStream: null,\n  selectedDate: null,\n  isPlaying: false,\n  currentSegmentIndex: -1,\n  zoomLevel: 1, // 1 = 1 hour, 2 = 30 minutes, 4 = 15 minutes\n  timelineStartHour: 0,\n  timelineEndHour: 24,\n  currentTime: null,\n  prevCurrentTime: null,\n  playbackSpeed: 1.0,\n  showOnlySegments: true,\n  forceReload: false,\n  userControllingCursor: false, // New flag to track if user is controlling cursor\n  listeners: new Set(),\n\n  // Last time state was updated\n  lastUpdateTime: 0,\n\n  // Pending state updates\n  pendingUpdates: {},\n\n  // Update state and notify listeners\n  setState(newState) {\n    const now = Date.now();\n\n    console.log('timelineState: setState called with', newState);\n    console.log('timelineState: current state before update', {\n      currentTime: this.currentTime,\n      currentSegmentIndex: this.currentSegmentIndex,\n      segmentsLength: this.timelineSegments.length\n    });\n\n    // For time-sensitive updates (like currentTime), we want to batch them\n    // to prevent too many updates in a short period\n    if (newState.currentTime !== undefined &&\n        !newState.currentSegmentIndex &&\n        !newState.isPlaying &&\n        now - this.lastUpdateTime < 250) {\n      // Skip frequent time updates that don't change playback state\n      console.log('timelineState: Skipping frequent time update');\n      return;\n    }\n\n    // Apply the new state\n    Object.assign(this, newState);\n\n    // Reset forceReload flag immediately\n    if (newState.forceReload) {\n      this.forceReload = false;\n    }\n\n    this.lastUpdateTime = now;\n\n    console.log('timelineState: state after update', {\n      currentTime: this.currentTime,\n      currentSegmentIndex: this.currentSegmentIndex,\n      segmentsLength: this.timelineSegments.length\n    });\n\n    this.notifyListeners();\n  },\n\n  // Subscribe to state changes\n  subscribe(listener) {\n    this.listeners.add(listener);\n    return () => this.listeners.delete(listener);\n  },\n\n  // Notify all listeners of state change\n  notifyListeners() {\n    this.listeners.forEach(listener => listener(this));\n  },\n\n  // Flush any pending updates\n  flushPendingUpdates() {\n    if (Object.keys(this.pendingUpdates).length > 0) {\n      Object.assign(this, this.pendingUpdates);\n      this.pendingUpdates = {};\n      this.lastUpdateTime = Date.now();\n      this.notifyListeners();\n    }\n  }\n};\n\n/**\n * Format date for input element\n */\nfunction formatDateForInput(date) {\n  const year = date.getFullYear();\n  const month = String(date.getMonth() + 1).padStart(2, '0');\n  const day = String(date.getDate()).padStart(2, '0');\n  return `${year}-${month}-${day}`;\n}\n\n/**\n * Parse URL parameters\n */\nfunction parseUrlParams() {\n  const params = new URLSearchParams(window.location.search);\n  return {\n    stream: params.get('stream') || '',\n    date: params.get('date') || formatDateForInput(new Date())\n  };\n}\n\n/**\n * Update URL parameters\n */\nfunction updateUrlParams(stream, date) {\n  if (!stream) return;\n  const url = new URL(window.location.href);\n  url.searchParams.set('stream', stream);\n  url.searchParams.set('date', date);\n  window.history.replaceState({}, '', url);\n}\n\n/**\n * TimelinePage component\n */\nexport function TimelinePage() {\n  // Get initial values from URL parameters\n  const urlParams = parseUrlParams();\n\n  // State\n  const [isLoading, setIsLoading] = useState(false);\n  const [streamsList, setStreamsList] = useState([]);\n  const [selectedStream, setSelectedStream] = useState(urlParams.stream);\n  const [selectedDate, setSelectedDate] = useState(urlParams.date);\n  const [segments, setSegments] = useState([]);\n\n  // Refs\n  const timelineContainerRef = useRef(null);\n  const initialLoadRef = useRef(false);\n  const flushIntervalRef = useRef(null);\n\n  // Set up periodic flush of pending updates\n  useEffect(() => {\n    // Set up interval to flush pending updates every 200ms\n    flushIntervalRef.current = setInterval(() => {\n      timelineState.flushPendingUpdates();\n    }, 200);\n\n    // Clean up interval on unmount\n    return () => {\n      if (flushIntervalRef.current) {\n        clearInterval(flushIntervalRef.current);\n      }\n    };\n  }, []);\n\n  // Load streams using preact-query\n  const {\n    data: streamsData,\n    isLoading: isLoadingStreams,\n    error: streamsError\n  } = useQuery('streams', '/api/streams', {\n    timeout: 15000, // 15 second timeout\n    retries: 2,     // Retry twice\n    retryDelay: 1000 // 1 second between retries\n  });\n\n  // Handle initial data load when streams are available\n  useEffect(() => {\n    if (streamsData && Array.isArray(streamsData) && streamsData.length > 0 && !initialLoadRef.current) {\n      console.log('TimelinePage: Streams loaded, initializing data');\n      initialLoadRef.current = true;\n\n      // Update streamsList state\n      setStreamsList(streamsData);\n\n      // Update global state for child components\n      timelineState.setState({ streams: streamsData });\n\n      // Check if the selected stream from URL exists\n      const streamExists = streamsData.some(s => s.name === selectedStream);\n\n      if (streamExists && selectedStream) {\n        console.log(`TimelinePage: Using stream from URL: ${selectedStream}`);\n      } else if (streamsData.length > 0) {\n        // Use first stream if URL stream doesn't exist\n        const firstStream = streamsData[0].name;\n        console.log(`TimelinePage: Using first stream: ${firstStream}`);\n        setSelectedStream(firstStream);\n      }\n    }\n  }, [streamsData]);\n\n  // Handle streams error\n  useEffect(() => {\n    if (streamsError) {\n      console.error('TimelinePage: Error loading streams:', streamsError);\n      showStatusMessage('Error loading streams: ' + streamsError.message, 'error');\n    }\n  }, [streamsError]);\n\n  // Calculate time range for timeline data\n  const getTimeRange = (date) => {\n    const startDate = new Date(date);\n    startDate.setHours(0, 0, 0, 0);\n\n    const endDate = new Date(date);\n    endDate.setHours(23, 59, 59, 999);\n\n    return {\n      startTime: startDate.toISOString(),\n      endTime: endDate.toISOString()\n    };\n  };\n\n  // Update URL and global state when stream or date changes\n  useEffect(() => {\n    if (selectedStream) {\n      // Update URL\n      updateUrlParams(selectedStream, selectedDate);\n\n      // Update global state\n      timelineState.setState({\n        selectedStream,\n        selectedDate\n      });\n    }\n  }, [selectedStream, selectedDate]);\n\n  // Get time range for current date\n  const { startTime, endTime } = getTimeRange(selectedDate);\n\n  // Fetch timeline segments using preact-query\n  const {\n    data: timelineData,\n    isLoading: isLoadingTimeline,\n    error: timelineError,\n    refetch: refetchTimeline\n  } = useQuery(\n    ['timeline-segments', selectedStream, selectedDate],\n    selectedStream ? `/api/timeline/segments?stream=${encodeURIComponent(selectedStream)}&start=${encodeURIComponent(startTime)}&end=${encodeURIComponent(endTime)}` : null,\n    {\n      timeout: 30000, // 30 second timeout\n      retries: 2,     // Retry twice\n      retryDelay: 1000 // 1 second between retries\n    },\n    {\n      enabled: !!selectedStream, // Only run query if we have a selected stream\n      onSuccess: (data) => {\n        console.log('TimelinePage: Timeline data received:', data);\n        const timelineSegments = data.segments || [];\n        console.log(`TimelinePage: Received ${timelineSegments.length} segments`);\n\n        if (timelineSegments.length === 0) {\n          console.log('TimelinePage: No segments found');\n          setSegments([]);\n\n          // Update global state\n          timelineState.setState({\n            timelineSegments: [],\n            currentSegmentIndex: -1,\n            currentTime: null,\n            isPlaying: false\n          });\n\n          showStatusMessage('No recordings found for the selected date', 'warning');\n          return;\n        }\n\n        // IMPORTANT: Make a deep copy of the segments to avoid reference issues\n        const segmentsCopy = JSON.parse(JSON.stringify(timelineSegments));\n\n        // Log the first few segments for debugging\n        segmentsCopy.slice(0, 3).forEach((segment, i) => {\n          const startTime = new Date(segment.start_timestamp * 1000);\n          const endTime = new Date(segment.end_timestamp * 1000);\n          console.log(`TimelinePage: Segment ${i} - Start: ${startTime.toLocaleTimeString()}, End: ${endTime.toLocaleTimeString()}`);\n        });\n\n        console.log('TimelinePage: Setting segments');\n        setSegments(segmentsCopy);\n\n        // Force a synchronous DOM update\n        document.body.offsetHeight;\n\n        // Directly update the global state with the segments\n        const firstSegmentStartTime = segmentsCopy[0].start_timestamp;\n\n        console.log('TimelinePage: Setting initial segment and time', {\n          firstSegmentId: segmentsCopy[0].id,\n          startTime: new Date(firstSegmentStartTime * 1000).toLocaleTimeString()\n        });\n\n        // DIRECT ASSIGNMENT to ensure state is properly set\n        console.log('TimelinePage: Directly setting timelineState properties');\n        timelineState.timelineSegments = segmentsCopy;\n        timelineState.currentSegmentIndex = 0;\n        timelineState.currentTime = firstSegmentStartTime;\n        timelineState.prevCurrentTime = firstSegmentStartTime;\n        timelineState.isPlaying = false;\n        timelineState.forceReload = true;\n        timelineState.zoomLevel = 1;\n        timelineState.selectedDate = selectedDate; // Make sure the date is set\n\n        // Now call setState to notify listeners\n        timelineState.setState({\n          // Empty object just to trigger notification\n        });\n\n        console.log('TimelinePage: Updated timelineState with segments');\n\n        // Wait a moment to ensure state is updated, then log the current state\n        setTimeout(() => {\n          console.log('TimelinePage: State after update (delayed check):', {\n            segmentsLength: timelineState.timelineSegments.length,\n            currentSegmentIndex: timelineState.currentSegmentIndex,\n            currentTime: timelineState.currentTime\n          });\n\n          // Force a state update if the state wasn't properly updated\n          if (!timelineState.currentTime || timelineState.currentSegmentIndex === -1) {\n            console.log('TimelinePage: State not properly updated, forcing update');\n            timelineState.setState({\n              currentSegmentIndex: 0,\n              currentTime: firstSegmentStartTime,\n              prevCurrentTime: firstSegmentStartTime\n            });\n          }\n        }, 100);\n\n        // Preload the first segment's video\n        const videoPlayer = document.querySelector('#video-player video');\n        if (videoPlayer) {\n          videoPlayer.src = `/api/recordings/play/${segmentsCopy[0].id}?t=${Date.now()}`;\n          videoPlayer.load();\n        }\n\n        showStatusMessage(`Loaded ${segmentsCopy.length} recording segments`, 'success');\n      },\n      onError: (error) => {\n        console.error('TimelinePage: Error loading timeline data:', error);\n        showStatusMessage('Error loading timeline data: ' + error.message, 'error');\n        setSegments([]);\n      }\n    }\n  );\n\n  // Handle stream selection change\n  const handleStreamChange = (e) => {\n    const newStream = e.target.value;\n    console.log(`TimelinePage: Stream changed to ${newStream}`);\n    setSelectedStream(newStream);\n  };\n\n  // Handle date selection change\n  const handleDateChange = (e) => {\n    const newDate = e.target.value;\n    console.log(`TimelinePage: Date changed to ${newDate}`);\n    setSelectedDate(newDate);\n  };\n\n  // Render content based on state\n  const renderContent = () => {\n    if (isLoadingTimeline) {\n      return html`<${LoadingIndicator} message=\"Loading timeline data...\" />`;\n    }\n\n    if (segments.length === 0) {\n      return html`\n        <div class=\"flex flex-col items-center justify-center py-12 text-center\">\n          <svg class=\"w-16 h-16 text-gray-400 dark:text-gray-600 mb-4\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\" xmlns=\"http://www.w3.org/2000/svg\">\n            <path stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\" d=\"M9.172 16.172a4 4 0 015.656 0M9 10h.01M15 10h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z\"></path>\n          </svg>\n          <p class=\"text-gray-600 dark:text-gray-400 text-lg\">No recordings found for the selected date and stream</p>\n        </div>\n      `;\n    }\n\n    return html`\n      <!-- Video player -->\n      <${TimelinePlayer} />\n\n      <!-- Playback controls -->\n      <${TimelineControls} />\n\n        <!-- Timeline -->\n        <div\n            id=\"timeline-container\"\n            class=\"relative w-full h-24 bg-gray-200 dark:bg-gray-700 border border-gray-300 dark:border-gray-600 rounded-lg mb-6 overflow-hidden\"\n            ref=${timelineContainerRef}\n        >\n          <${TimelineRuler} />\n          <${TimelineSegments} segments=${segments} />\n          <${TimelineCursor} />\n\n          <!-- Instructions for cursor -->\n          <div class=\"absolute bottom-1 right-2 text-xs text-gray-500 dark:text-gray-400 bg-white dark:bg-gray-800 bg-opacity-75 dark:bg-opacity-75 px-2 py-1 rounded\">\n            Drag the orange dial to navigate\n          </div>\n        </div>\n    `;\n  };\n\n  return html`\n    <div class=\"timeline-page\">\n      <div class=\"flex items-center mb-4\">\n        <h1 class=\"text-2xl font-bold\">Timeline Playback</h1>\n        <div class=\"ml-4 flex\">\n          <a href=\"recordings.html\" class=\"px-3 py-1 bg-gray-300 text-gray-700 dark:bg-gray-700 dark:text-gray-300 hover:bg-gray-400 dark:hover:bg-gray-600 rounded-l-md\">Table View</a>\n          <a href=\"timeline.html\" class=\"px-3 py-1 bg-blue-500 text-white rounded-r-md\">Timeline View</a>\n        </div>\n      </div>\n\n      <!-- Stream selector and date picker -->\n      <div class=\"flex flex-wrap gap-4 mb-2\">\n        <div class=\"stream-selector flex-grow\">\n          <div class=\"flex justify-between items-center mb-2\">\n            <label for=\"stream-selector\">Stream</label>\n            <button\n              class=\"text-xs bg-gray-200 hover:bg-gray-300 dark:bg-gray-700 dark:hover:bg-gray-600 px-2 py-1 rounded\"\n              onClick=${() => refetchTimeline()}\n            >\n              Reload Data\n            </button>\n          </div>\n          <select\n              id=\"stream-selector\"\n              class=\"w-full p-2 border rounded dark:bg-gray-700 dark:border-gray-600 dark:text-white\"\n              value=${selectedStream || ''}\n              onChange=${handleStreamChange}\n          >\n            <option value=\"\" disabled>Select a stream (${streamsList.length} available)</option>\n            ${streamsList.map(stream => html`\n              <option key=${stream.name} value=${stream.name}>${stream.name}</option>\n            `)}\n          </select>\n        </div>\n\n        <div class=\"date-selector flex-grow\">\n          <label for=\"timeline-date\" class=\"block mb-2\">Date</label>\n          <input\n              type=\"date\"\n              id=\"timeline-date\"\n              class=\"w-full p-2 border rounded dark:bg-gray-700 dark:border-gray-600 dark:text-white\"\n              value=${selectedDate}\n              onChange=${handleDateChange}\n          />\n        </div>\n      </div>\n\n      <!-- Auto-load message -->\n      <div class=\"mb-4 text-sm text-gray-500 dark:text-gray-400 italic\">\n        ${isLoadingTimeline ? 'Loading...' : 'Recordings auto-load when stream or date changes'}\n      </div>\n\n      <!-- Current time display -->\n      <div class=\"flex justify-between items-center mb-2\">\n        <div id=\"time-display\" class=\"timeline-time-display bg-gray-200 dark:bg-gray-700 px-3 py-1 rounded font-mono text-base\">00:00:00</div>\n      </div>\n\n      <!-- Debug info -->\n      <div class=\"mb-2 text-xs text-gray-500\">\n        Debug - isLoading: ${isLoadingTimeline ? 'true' : 'false'},\n        Streams: ${streamsList.length},\n        Segments: ${segments.length}\n      </div>\n\n      <!-- Content -->\n      ${renderContent()}\n\n      <!-- Instructions -->\n      <div class=\"mt-6 p-4 bg-gray-200 dark:bg-gray-800 rounded\">\n        <h3 class=\"text-lg font-semibold mb-2\">How to use the timeline:</h3>\n        <ul class=\"list-disc pl-5\">\n          <li>Select a stream and date to load recordings</li>\n          <li>Click on the timeline to position the cursor at a specific time</li>\n          <li>Drag the orange cursor to navigate precisely</li>\n          <li>Click on a segment (blue bar) to play that recording</li>\n          <li>Use the play button to start playback from the current cursor position</li>\n          <li>Use the zoom buttons to adjust the timeline scale</li>\n        </ul>\n      </div>\n    </div>\n  `;\n}\n\n// Export the timeline state for use in other components\nexport { timelineState };\n"],"names":["TimelineControls","isPlaying","setIsPlaying","useState","zoomLevel","setZoomLevel","useEffect","unsubscribe","timelineState","subscribe","state","pausePlayback","setState","videoPlayer","document","querySelector","pause","resumePlayback","timelineSegments","length","showStatusMessage","console","log","segments","currentSegmentIndex","currentTime","selectedDate","segmentToPlay","segmentIndex","relativeTime","i","segment","start_timestamp","end_timestamp","closestIndex","minDistance","Infinity","midpoint","distance","Math","abs","id","directVideoControl","setTimeout","resetDirectControl","videoElement","handleMetadataLoaded","duration","width","videoWidth","height","videoHeight","segmentDuration","validTime","max","min","play","then","checkPlayback","attempt","paused","catch","e","error","monitorInterval","setInterval","clearInterval","message","removeEventListener","addEventListener","src","Date","now","load","html","togglePlayback","segmentsCount","zoomOut","newZoomLevel","zoomIn","TimelineRuler","startHour","setStartHour","endHour","setEndHour","hoursPerView","centerHour","currentDate","getHours","getMinutes","getSeconds","earliestHour","latestHour","forEach","startTime","endTime","newStartHour","newEndHour","timelineStartHour","timelineEndHour","generateHourMarkers","markers","hour","floor","ceil","position","push","halfHourPosition","quarterHourPosition1","quarterHourPosition3","round","TimelineSegments","propSegments","setSegments","setCurrentSegmentIndex","containerRef","useRef","isDragging","lastSegmentsUpdateRef","lastSegmentsRef","current","JSON","stringify","forceReload","undefined","container","handleMouseDown","target","classList","contains","handleTimelineClick","handleMouseMove","handleMouseUp","event","rect","getBoundingClientRect","clickX","clientX","left","containerWidth","clickHour","clickDate","setHours","setMinutes","setSeconds","clickTimestamp","getTime","prevCurrentTime","foundSegment","startTimestamp","local_start_timestamp","endTimestamp","local_end_timestamp","playSegment","index","warn","absoluteTime","body","offsetHeight","removeAttribute","onloadedmetadata","seekTime","renderSegments","visibleSegments","hourMap","Map","visibleCount","skippedCount","startHourFloat","endHourFloat","startFloorHour","endCeilHour","h","has","set","get","mergedSegments","currentMergedSegment","sort","a","b","originalIndices","has_detection","mergedIndex","segStartTimestamp","segEndTimestamp","visibleStartHour","visibleEndHour","startPercent","widthPercent","durationStr","startTimeStr","toLocaleTimeString","endTimeStr","TimelineCursor","setPosition","visible","setVisible","setCurrentTime","setIsDragging","cursorRef","dragStartXRef","debouncedUpdateCursorPosition","debounce","func","delay","timeoutId","args","clearTimeout","apply","this","time","startHr","endHr","updateCursorPosition","userControllingCursor","updateTimeDisplay","cursor","preventDefault","stopPropagation","parentElement","positionPercent","date","setTime","setMilliseconds","timestamp","hourRange","dateTime","toLocaleString","closestSegment","timeString","timeDisplay","getElementById","hours","toString","padStart","minutes","seconds","textContent","initCursor","segmentsLength","SpeedControls","currentSpeed","setCurrentSpeed","playbackSpeed","map","speed","playbackRate","setPlaybackSpeed","TimelinePlayer","videoRef","lastTimeUpdateRef","lastSegmentIdRef","handleVideoPlayback","video","segmentChanged","needsReload","timeChanged","loadSegment","autoplay","recordingUrl","onLoadedMetadata","handleEnded","nextIndex","handleTimeUpdate","mainContent","innerHTML","render","QueryClientProvider","queryClient","TimelinePage","streams","selectedStream","showOnlySegments","listeners","Set","lastUpdateTime","pendingUpdates","newState","Object","assign","notifyListeners","listener","add","delete","flushPendingUpdates","keys","urlParams","params","URLSearchParams","window","location","search","stream","getFullYear","String","getMonth","getDate","parseUrlParams","isLoading","setIsLoading","streamsList","setStreamsList","setSelectedStream","setSelectedDate","timelineContainerRef","initialLoadRef","flushIntervalRef","data","streamsData","isLoadingStreams","streamsError","useQuery","timeout","retries","retryDelay","Array","isArray","some","s","name","firstStream","url","URL","href","searchParams","history","replaceState","updateUrlParams","startDate","endDate","toISOString","getTimeRange","timelineData","isLoadingTimeline","timelineError","refetch","refetchTimeline","encodeURIComponent","enabled","onSuccess","segmentsCopy","parse","slice","firstSegmentStartTime","firstSegmentId","onError","newStream","value","newDate","LoadingIndicator"],"mappings":"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"}