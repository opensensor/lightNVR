{"version":3,"file":"timeline-e00so_k8.js","sources":["../../js/components/preact/timeline/TimelineControls.jsx","../../js/components/preact/timeline/TimelineRuler.jsx","../../js/components/preact/timeline/TimelineSegments.jsx","../../js/components/preact/timeline/TimelineCursor.jsx","../../js/components/preact/timeline/SpeedControls.jsx","../../js/components/preact/timeline/TimelinePlayer.jsx","../../js/components/preact/timeline/TimelinePage.jsx","../../js/pages/timeline-page.jsx"],"sourcesContent":["/**\n * LightNVR Timeline Controls Component\n * Handles play/pause and zoom controls for the timeline\n */\n\nimport { useState, useEffect } from 'preact/hooks';\nimport { timelineState } from './TimelinePage.jsx';\nimport { showStatusMessage } from '../ToastContainer.jsx';\n\n/**\n * TimelineControls component\n * @returns {JSX.Element} TimelineControls component\n */\nexport function TimelineControls() {\n  // Local state\n  const [isPlaying, setIsPlaying] = useState(false);\n  const [zoomLevel, setZoomLevel] = useState(1);\n\n  // Subscribe to timeline state changes\n  useEffect(() => {\n    const unsubscribe = timelineState.subscribe(state => {\n      setIsPlaying(state.isPlaying);\n      setZoomLevel(state.zoomLevel);\n    });\n\n    return () => unsubscribe();\n  }, []);\n\n  // Toggle playback (play/pause)\n  const togglePlayback = () => {\n    console.log('TimelineControls: togglePlayback called');\n    console.log('TimelineControls: Current state before toggle:', {\n      isPlaying,\n      currentTime: timelineState.currentTime,\n      currentSegmentIndex: timelineState.currentSegmentIndex,\n      segmentsCount: timelineState.timelineSegments ? timelineState.timelineSegments.length : 0\n    });\n\n    if (isPlaying) {\n      pausePlayback();\n    } else {\n      resumePlayback();\n    }\n  };\n\n  // Pause playback\n  const pausePlayback = () => {\n    timelineState.setState({ isPlaying: false });\n\n    // If there's a video player, pause it\n    const videoPlayer = document.querySelector('#video-player video');\n    if (videoPlayer) {\n      videoPlayer.pause();\n    }\n  };\n\n  // Resume playback\n  const resumePlayback = () => {\n    // If no segments, show message and return\n    if (!timelineState.timelineSegments || timelineState.timelineSegments.length === 0) {\n      showStatusMessage('No recordings to play', 'warning');\n      return;\n    }\n\n    console.log('TimelineControls: resumePlayback called');\n    console.log('TimelineControls: Current state:', {\n      segments: timelineState.timelineSegments.length,\n      currentSegmentIndex: timelineState.currentSegmentIndex,\n      currentTime: timelineState.currentTime,\n      selectedDate: timelineState.selectedDate\n    });\n\n    // SIMPLIFIED APPROACH: Directly use the current time to find the appropriate segment\n    let segmentToPlay = null;\n    let segmentIndex = -1;\n    let relativeTime = 0;\n\n    // If we have a current time, find the segment that contains it\n    if (timelineState.currentTime !== null) {\n      console.log('TimelineControls: Using current time to find segment:', timelineState.currentTime);\n\n      // First try to find a segment that contains the current time\n      for (let i = 0; i < timelineState.timelineSegments.length; i++) {\n        const segment = timelineState.timelineSegments[i];\n        if (timelineState.currentTime >= segment.start_timestamp &&\n            timelineState.currentTime <= segment.end_timestamp) {\n          segmentToPlay = segment;\n          segmentIndex = i;\n          relativeTime = timelineState.currentTime - segment.start_timestamp;\n          console.log(`TimelineControls: Found segment ${i} containing current time, relative time: ${relativeTime}s`);\n          break;\n        }\n      }\n\n      // If no exact match, find the closest segment\n      if (!segmentToPlay) {\n        let closestIndex = 0;\n        let minDistance = Infinity;\n\n        for (let i = 0; i < timelineState.timelineSegments.length; i++) {\n          const segment = timelineState.timelineSegments[i];\n          const midpoint = (segment.start_timestamp + segment.end_timestamp) / 2;\n          const distance = Math.abs(timelineState.currentTime - midpoint);\n\n          if (distance < minDistance) {\n            minDistance = distance;\n            closestIndex = i;\n          }\n        }\n\n        segmentToPlay = timelineState.timelineSegments[closestIndex];\n        segmentIndex = closestIndex;\n\n        // Calculate the appropriate relative time based on the cursor position\n        if (timelineState.currentTime < segmentToPlay.start_timestamp) {\n          // If cursor is before the segment, start at the beginning\n          relativeTime = 0;\n        } else if (timelineState.currentTime > segmentToPlay.end_timestamp) {\n          // If cursor is after the segment, start at the end\n          relativeTime = segmentToPlay.end_timestamp - segmentToPlay.start_timestamp;\n        } else {\n          // If cursor is within the segment's time range but not exactly matching,\n          // calculate the relative position within the segment\n          relativeTime = timelineState.currentTime - segmentToPlay.start_timestamp;\n        }\n\n        console.log(`TimelineControls: Using closest segment ${closestIndex}, relative time: ${relativeTime}s`);\n      }\n    }\n    // If no current time but we have a valid segment index, use that\n    else if (timelineState.currentSegmentIndex >= 0 &&\n             timelineState.currentSegmentIndex < timelineState.timelineSegments.length) {\n      segmentIndex = timelineState.currentSegmentIndex;\n      segmentToPlay = timelineState.timelineSegments[segmentIndex];\n      relativeTime = 0;\n      console.log(`TimelineControls: Using current segment index ${segmentIndex}`);\n    }\n    // Fall back to the first segment\n    else {\n      segmentIndex = 0;\n      segmentToPlay = timelineState.timelineSegments[0];\n      relativeTime = 0;\n      console.log('TimelineControls: Falling back to first segment');\n    }\n\n    // DIRECT APPROACH: Manually load and play the video\n    console.log(`TimelineControls: Playing segment ${segmentIndex} (ID: ${segmentToPlay.id}) at time ${relativeTime}s`);\n\n    // First update the state\n    timelineState.currentSegmentIndex = segmentIndex;\n\n    // Check if we should preserve the cursor position\n    if (timelineState.preserveCursorPosition) {\n      // If the cursor position is locked, don't change the current time at all\n      console.log(`TimelineControls: Cursor position is locked, keeping current time ${timelineState.currentTime}`);\n    } else {\n      // Make sure we preserve the current time if it's within the segment\n      // This ensures the cursor stays where the user positioned it\n      if (timelineState.currentTime !== null &&\n          timelineState.currentTime >= segmentToPlay.start_timestamp &&\n          timelineState.currentTime <= segmentToPlay.end_timestamp) {\n        // Keep the current time as is - don't reset it\n        console.log(`TimelineControls: Keeping current time ${timelineState.currentTime} within segment`);\n      } else {\n        // Otherwise, set the time based on the calculated relative time\n        timelineState.currentTime = segmentToPlay.start_timestamp + relativeTime;\n        console.log(`TimelineControls: Setting current time to ${timelineState.currentTime} (segment start + ${relativeTime}s)`);\n      }\n    }\n\n    timelineState.isPlaying = true;\n    timelineState.directVideoControl = true; // Set flag to prevent TimelinePlayer interference\n\n    // Notify listeners\n    timelineState.setState({});\n\n    // Keep the directVideoControl flag active longer to ensure no interference\n    const resetDirectControl = () => {\n      console.log('TimelineControls: Resetting directVideoControl flag');\n      timelineState.directVideoControl = false;\n      timelineState.setState({});\n    };\n\n    // Reset the flag after a longer delay\n    setTimeout(resetDirectControl, 3000);\n\n    // Now directly control the video element\n    const videoElement = document.querySelector('#video-player video');\n    if (videoElement) {\n      // Pause any current playback\n      videoElement.pause();\n\n      // Set up event listener for when metadata is loaded\n      const handleMetadataLoaded = () => {\n        console.log(`TimelineControls: Video metadata loaded, setting time to ${relativeTime}s`);\n\n        try {\n          // Log the video duration\n          console.log('TimelineControls: Video metadata', {\n            duration: videoElement.duration,\n            width: videoElement.videoWidth,\n            height: videoElement.videoHeight,\n            segment: segmentToPlay.id,\n            segmentDuration: segmentToPlay.end_timestamp - segmentToPlay.start_timestamp\n          });\n\n          // Set the current time based on the cursor position\n          let timeToSet = relativeTime;\n\n          // Check if we should preserve the cursor position\n          if (timelineState.preserveCursorPosition && timelineState.currentTime !== null) {\n            // Calculate the relative time within the segment\n            if (timelineState.currentTime >= segmentToPlay.start_timestamp &&\n                timelineState.currentTime <= segmentToPlay.end_timestamp) {\n              // If the cursor is within this segment, use its position\n              timeToSet = timelineState.currentTime - segmentToPlay.start_timestamp;\n              console.log(`TimelineControls: Using locked cursor position for playback: ${timeToSet}s`);\n            } else {\n              // If the cursor is outside this segment but we want to preserve its position,\n              // use the beginning or end of the segment based on which is closer\n              const distanceToStart = Math.abs(timelineState.currentTime - segmentToPlay.start_timestamp);\n              const distanceToEnd = Math.abs(timelineState.currentTime - segmentToPlay.end_timestamp);\n\n              if (distanceToStart <= distanceToEnd) {\n                timeToSet = 0; // Use start of segment\n                console.log(`TimelineControls: Cursor outside segment, using start of segment`);\n              } else {\n                timeToSet = segmentToPlay.end_timestamp - segmentToPlay.start_timestamp; // Use end of segment\n                console.log(`TimelineControls: Cursor outside segment, using end of segment`);\n              }\n            }\n          } else if (timelineState.currentTime !== null &&\n                     timelineState.currentTime >= segmentToPlay.start_timestamp &&\n                     timelineState.currentTime <= segmentToPlay.end_timestamp) {\n            // If not preserving cursor position but the current time is within this segment,\n            // still use the relative position from the cursor\n            timeToSet = timelineState.currentTime - segmentToPlay.start_timestamp;\n            console.log(`TimelineControls: Using cursor position for playback: ${timeToSet}s`);\n          }\n\n          // Ensure the time is within valid bounds\n          let validTime = Math.max(0, Math.min(timeToSet, videoElement.duration || 0));\n\n          // If we're very close to the start of the segment but not exactly at the start,\n          // add a small offset to prevent snapping to the start\n          if (validTime > 0 && validTime < 1.0) {\n            // Ensure we're at least 1 second into the segment\n            validTime = 1.0;\n            console.log(`TimelineControls: Adjusting video time to ${validTime}s to prevent snapping to segment start`);\n          }\n\n          console.log(`TimelineControls: Setting video time to ${validTime}s`);\n          videoElement.currentTime = validTime;\n\n          // Start playback with a small delay to avoid conflicts\n          setTimeout(() => {\n            if (timelineState.isPlaying) {\n              console.log('TimelineControls: Starting video playback');\n              videoElement.play().then(() => {\n                console.log('TimelineControls: Video playback started successfully');\n\n                // Set up multiple checks to ensure playback continues\n                const checkPlayback = (attempt = 1) => {\n                  if (attempt > 5) return; // Limit to 5 attempts\n\n                  setTimeout(() => {\n                    if (videoElement.paused && timelineState.isPlaying) {\n                      console.log(`TimelineControls: Video paused unexpectedly (attempt ${attempt}), trying to resume`);\n                      videoElement.play().catch(e => {\n                        console.error(`Error resuming video (attempt ${attempt}):`, e);\n                      });\n\n                      // Try again after a delay\n                      checkPlayback(attempt + 1);\n                    }\n                  }, 500 * attempt); // Increasing delays between attempts\n                };\n\n                // Start the playback checks\n                checkPlayback();\n\n                // Set up a check to ensure the video plays for the full segment duration\n                const segmentDuration = segmentToPlay.end_timestamp - segmentToPlay.start_timestamp;\n                console.log(`TimelineControls: Segment duration: ${segmentDuration}s, video duration: ${videoElement.duration}s`);\n\n                // If the video duration is significantly shorter than the segment duration,\n                // we need to ensure the video plays for the full segment duration\n                if (videoElement.duration < segmentDuration - 1) { // Allow 1 second tolerance\n                  console.log('TimelineControls: Video duration is shorter than segment duration, will monitor playback');\n\n                  // Monitor playback to ensure it continues for the full segment duration\n                  const monitorInterval = setInterval(() => {\n                    if (!timelineState.isPlaying || !videoElement) {\n                      clearInterval(monitorInterval);\n                      return;\n                    }\n\n                    // If we're near the end of the video but not the end of the segment,\n                    // reset to the beginning and continue playing\n                    if (videoElement.currentTime > videoElement.duration - 0.5 &&\n                        relativeTime + videoElement.currentTime < segmentDuration) {\n                      console.log('TimelineControls: Reached end of video but not end of segment, restarting video');\n                      videoElement.currentTime = 0;\n                      videoElement.play().catch(e => {\n                        console.error('Error restarting video:', e);\n                      });\n                    }\n                  }, 500);\n                }\n              }).catch(e => {\n                console.error('Error playing video:', e);\n                showStatusMessage('Error playing video: ' + e.message, 'error');\n              });\n            }\n          }, 100);\n        } catch (error) {\n          console.error('TimelineControls: Error in handleMetadataLoaded:', error);\n        } finally {\n          // Remove the event listener\n          videoElement.removeEventListener('loadedmetadata', handleMetadataLoaded);\n        }\n      };\n\n      // Add the event listener\n      videoElement.addEventListener('loadedmetadata', handleMetadataLoaded);\n\n      // Set the new source\n      console.log(`TimelineControls: Loading video from segment ${segmentToPlay.id}`);\n      videoElement.src = `/api/recordings/play/${segmentToPlay.id}?t=${Date.now()}`;\n      videoElement.load();\n    } else {\n      console.error('TimelineControls: No video element found');\n      showStatusMessage('Error: Video player not found', 'error');\n    }\n  };\n\n  // Play a specific segment\n  const playSegment = (index) => {\n    // This function will be implemented in the TimelinePlayer component\n    // Here we just update the state\n    timelineState.setState({\n      currentSegmentIndex: index,\n      isPlaying: true\n    });\n  };\n\n  // Zoom in on timeline\n  const zoomIn = () => {\n    if (zoomLevel < 8) {\n      const newZoomLevel = zoomLevel * 2;\n      timelineState.setState({ zoomLevel: newZoomLevel });\n      showStatusMessage(`Zoomed in: ${24 / newZoomLevel} hours view`, 'info');\n    }\n  };\n\n  // Zoom out on timeline\n  const zoomOut = () => {\n    if (zoomLevel > 1) {\n      const newZoomLevel = zoomLevel / 2;\n      timelineState.setState({ zoomLevel: newZoomLevel });\n      showStatusMessage(`Zoomed out: ${24 / newZoomLevel} hours view`, 'info');\n    }\n  };\n\n  return (\n    <div className=\"timeline-controls flex justify-between items-center mb-2\">\n      <div className=\"flex items-center\">\n        <button\n          id=\"play-button\"\n          className=\"w-10 h-10 rounded-full bg-green-600 hover:bg-green-700 text-white flex items-center justify-center focus:outline-none focus:ring-1 focus:ring-green-500 focus:ring-offset-1 transition-colors shadow-sm mr-2\"\n          onClick={togglePlayback}\n          title={isPlaying ? 'Pause' : 'Play from current position'}\n        >\n          <svg xmlns=\"http://www.w3.org/2000/svg\" className=\"h-5 w-5\" fill=\"none\" viewBox=\"0 0 24 24\" stroke=\"currentColor\">\n            {isPlaying ? (\n              <>\n                {/* Pause icon - two vertical bars */}\n                <rect x=\"6\" y=\"6\" width=\"4\" height=\"12\" rx=\"1\" fill=\"white\" />\n                <rect x=\"14\" y=\"6\" width=\"4\" height=\"12\" rx=\"1\" fill=\"white\" />\n              </>\n            ) : (\n              <>\n                {/* Play icon - triangle */}\n                <path d=\"M8 5.14v14l11-7-11-7z\" fill=\"white\" />\n              </>\n            )}\n          </svg>\n        </button>\n        <span className=\"text-xs text-gray-600 dark:text-gray-300\">Play from current position</span>\n      </div>\n\n      <div className=\"flex items-center gap-1\">\n        <span className=\"text-xs text-gray-600 dark:text-gray-300 mr-1\">Zoom:</span>\n        <button\n          id=\"zoom-out-button\"\n          className=\"w-6 h-6 rounded bg-gray-200 dark:bg-gray-700 hover:bg-gray-300 dark:hover:bg-gray-600 flex items-center justify-center focus:outline-none focus:ring-1 focus:ring-blue-500 transition-colors\"\n          onClick={zoomOut}\n          title=\"Zoom Out (Show more time)\"\n          disabled={zoomLevel <= 1}\n        >\n          <svg xmlns=\"http://www.w3.org/2000/svg\" className=\"h-4 w-4\" fill=\"none\" viewBox=\"0 0 24 24\" stroke=\"currentColor\">\n            <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth=\"2\" d=\"M15 12H9m12 0a9 9 0 11-18 0 9 9 0 0118 0z\" />\n          </svg>\n        </button>\n        <button\n          id=\"zoom-in-button\"\n          className=\"w-6 h-6 rounded bg-gray-200 dark:bg-gray-700 hover:bg-gray-300 dark:hover:bg-gray-600 flex items-center justify-center focus:outline-none focus:ring-1 focus:ring-blue-500 transition-colors\"\n          onClick={zoomIn}\n          title=\"Zoom In (Show less time)\"\n          disabled={zoomLevel >= 8}\n        >\n          <svg xmlns=\"http://www.w3.org/2000/svg\" className=\"h-4 w-4\" fill=\"none\" viewBox=\"0 0 24 24\" stroke=\"currentColor\">\n            <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth=\"2\" d=\"M12 9v3m0 0v3m0-3h3m-3 0H9m12 0a9 9 0 11-18 0 9 9 0 0118 0z\" />\n          </svg>\n        </button>\n      </div>\n    </div>\n  );\n}\n","/**\n * LightNVR Timeline Ruler Component\n * Displays the time ruler with hour markers\n */\n\nimport { useState, useEffect } from 'preact/hooks';\nimport { timelineState } from './TimelinePage.jsx';\n\n/**\n * TimelineRuler component\n * @returns {JSX.Element} TimelineRuler component\n */\nexport function TimelineRuler() {\n  // Local state\n  const [startHour, setStartHour] = useState(0);\n  const [endHour, setEndHour] = useState(24);\n  const [zoomLevel, setZoomLevel] = useState(1);\n\n  // Subscribe to timeline state changes\n  useEffect(() => {\n    const unsubscribe = timelineState.subscribe(state => {\n      console.log('TimelineRuler: State update received', {\n        zoomLevel: state.zoomLevel,\n        segmentsCount: state.timelineSegments ? state.timelineSegments.length : 0,\n        currentTime: state.currentTime\n      });\n\n      // Calculate time range based on zoom level\n      const hoursPerView = 24 / state.zoomLevel;\n\n      // Calculate the center hour based on current time or segments\n      let centerHour = 12; // Default to noon\n\n      if (state.currentTime !== null) {\n        // If we have a current time, use it as the center\n        const currentDate = new Date(state.currentTime * 1000);\n        centerHour = currentDate.getHours() + (currentDate.getMinutes() / 60) + (currentDate.getSeconds() / 3600);\n      } else if (state.timelineSegments && state.timelineSegments.length > 0) {\n        // If we have segments but no current time, use the middle of the segments\n        let earliestHour = 24;\n        let latestHour = 0;\n\n        state.timelineSegments.forEach(segment => {\n          const startTime = new Date(segment.start_timestamp * 1000);\n          const endTime = new Date(segment.end_timestamp * 1000);\n\n          const startHour = startTime.getHours() + (startTime.getMinutes() / 60) + (startTime.getSeconds() / 3600);\n          const endHour = endTime.getHours() + (endTime.getMinutes() / 60) + (endTime.getSeconds() / 3600);\n\n          earliestHour = Math.min(earliestHour, startHour);\n          latestHour = Math.max(latestHour, endHour);\n        });\n\n        centerHour = (earliestHour + latestHour) / 2;\n        console.log('TimelineRuler: Calculated center from segments', { earliestHour, latestHour, centerHour });\n      }\n\n      // Calculate start and end hours based on center and zoom level\n      let newStartHour = Math.max(0, centerHour - (hoursPerView / 2));\n      let newEndHour = Math.min(24, newStartHour + hoursPerView);\n\n      // Adjust start hour if end hour is at the limit\n      if (newEndHour === 24 && hoursPerView < 24) {\n        newStartHour = Math.max(0, 24 - hoursPerView);\n        newEndHour = 24;\n      } else if (newStartHour === 0 && hoursPerView < 24) {\n        newEndHour = Math.min(24, hoursPerView);\n      }\n\n      // Update local state\n      setStartHour(newStartHour);\n      setEndHour(newEndHour);\n      setZoomLevel(state.zoomLevel);\n\n      console.log('TimelineRuler: Calculated time range', {\n        newStartHour,\n        newEndHour,\n        hoursPerView,\n        centerHour\n      });\n\n      // Only update global state if the values have actually changed\n      // to prevent infinite recursion\n      if (timelineState.timelineStartHour !== newStartHour ||\n          timelineState.timelineEndHour !== newEndHour) {\n        console.log('TimelineRuler: Updating global state with new time range');\n        timelineState.setState({\n          timelineStartHour: newStartHour,\n          timelineEndHour: newEndHour\n        });\n      }\n    });\n\n    return () => unsubscribe();\n  }, []);\n\n  // Generate hour markers and labels\n  const generateHourMarkers = () => {\n    const markers = [];\n    const hourWidth = 100 / (endHour - startHour);\n\n    // Add hour markers and labels\n    for (let hour = Math.floor(startHour); hour <= Math.ceil(endHour); hour++) {\n      if (hour >= 0 && hour <= 24) {\n        const position = ((hour - startHour) / (endHour - startHour)) * 100;\n\n        // Add hour marker\n        markers.push(\n          <div\n            key={`tick-${hour}`}\n            className=\"absolute top-0 w-px h-5 bg-gray-500 dark:bg-gray-400\"\n            style={{ left: `${position}%` }}\n          ></div>\n        );\n\n        // Add hour label\n        markers.push(\n          <div\n            key={`label-${hour}`}\n            className=\"absolute top-0 text-xs text-gray-600 dark:text-gray-300 transform -translate-x-1/2\"\n            style={{ left: `${position}%` }}\n          >\n            {hour}:00\n          </div>\n        );\n\n        // Add half-hour marker if not the last hour and we're zoomed in enough\n        if (hour < 24 && zoomLevel >= 2) {\n          const halfHourPosition = ((hour + 0.5 - startHour) / (endHour - startHour)) * 100;\n          markers.push(\n            <div\n              key={`tick-${hour}-30`}\n              className=\"absolute top-2 w-px h-3 bg-gray-400 dark:bg-gray-500\"\n              style={{ left: `${halfHourPosition}%` }}\n            ></div>\n          );\n\n          // Add 15-minute markers if zoomed in even more\n          if (zoomLevel >= 4) {\n            const quarterHourPosition1 = ((hour + 0.25 - startHour) / (endHour - startHour)) * 100;\n            const quarterHourPosition3 = ((hour + 0.75 - startHour) / (endHour - startHour)) * 100;\n\n            markers.push(\n              <div\n                key={`tick-${hour}-15`}\n                className=\"absolute top-3 w-px h-2 bg-gray-400 dark:bg-gray-500\"\n                style={{ left: `${quarterHourPosition1}%` }}\n              ></div>\n            );\n\n            markers.push(\n              <div\n                key={`tick-${hour}-45`}\n                className=\"absolute top-3 w-px h-2 bg-gray-400 dark:bg-gray-500\"\n                style={{ left: `${quarterHourPosition3}%` }}\n              ></div>\n            );\n          }\n        }\n      }\n    }\n\n    return markers;\n  };\n\n  return (\n    <div className=\"timeline-ruler relative w-full h-8 bg-gray-300 dark:bg-gray-800 border-b border-gray-400 dark:border-gray-600\">\n      {generateHourMarkers()}\n      <div className=\"absolute bottom-0 left-0 text-xs text-gray-500 px-1\">\n        Zoom: {zoomLevel}x ({Math.round(24 / zoomLevel)} hours)\n      </div>\n    </div>\n  );\n}\n","/**\n * LightNVR Timeline Segments Component\n * Displays recording segments on the timeline\n */\n\nimport { useState, useEffect, useRef } from 'preact/hooks';\nimport { timelineState } from './TimelinePage.jsx';\n\n/**\n * TimelineSegments component\n * @param {Object} props Component props\n * @param {Array} props.segments Array of timeline segments\n * @returns {JSX.Element} TimelineSegments component\n */\nexport function TimelineSegments({ segments: propSegments }) {\n  // Local state\n  const [segments, setSegments] = useState(propSegments || []);\n  const [startHour, setStartHour] = useState(0);\n  const [endHour, setEndHour] = useState(24);\n  const [currentSegmentIndex, setCurrentSegmentIndex] = useState(-1);\n\n  // Update segments when props change\n  useEffect(() => {\n    console.log(`TimelineSegments: Received segments from props: ${propSegments ? propSegments.length : 0}`);\n    if (propSegments && propSegments.length > 0) {\n      setSegments(propSegments);\n    }\n  }, [propSegments]);\n\n  // Refs\n  const containerRef = useRef(null);\n  const isDragging = useRef(false);\n\n  // Track the last time segments were updated to prevent too frequent updates\n  const lastSegmentsUpdateRef = useRef(0);\n  const lastSegmentsRef = useRef([]);\n\n  // Subscribe to timeline state changes\n  useEffect(() => {\n    const unsubscribe = timelineState.subscribe(state => {\n      console.log(`TimelineSegments: State update received, segments: ${state.timelineSegments ? state.timelineSegments.length : 0}`);\n\n      // Always update segments when they change\n      if (state.timelineSegments) {\n        // Check if segments have changed\n        const segmentsChanged = !lastSegmentsRef.current ||\n                               state.timelineSegments.length !== lastSegmentsRef.current.length ||\n                               JSON.stringify(state.timelineSegments) !== JSON.stringify(lastSegmentsRef.current) ||\n                               state.forceReload;\n\n        if (segmentsChanged) {\n          console.log(`TimelineSegments: Updating segments (${state.timelineSegments.length})`);\n          setSegments(state.timelineSegments);\n          lastSegmentsRef.current = [...state.timelineSegments]; // Create a copy\n          lastSegmentsUpdateRef.current = Date.now();\n        }\n      }\n\n      // Always update these lightweight properties\n      const newStartHour = state.timelineStartHour !== undefined ? state.timelineStartHour : 0;\n      const newEndHour = state.timelineEndHour !== undefined ? state.timelineEndHour : 24;\n\n      console.log(`TimelineSegments: Time range update - startHour: ${newStartHour}, endHour: ${newEndHour}`);\n\n      setStartHour(newStartHour);\n      setEndHour(newEndHour);\n      setCurrentSegmentIndex(state.currentSegmentIndex || -1);\n    });\n\n    // Initial load of segments\n    if (timelineState.timelineSegments && timelineState.timelineSegments.length > 0) {\n      console.log(`TimelineSegments: Initial load of segments (${timelineState.timelineSegments.length})`);\n      setSegments(timelineState.timelineSegments);\n      lastSegmentsRef.current = [...timelineState.timelineSegments];\n      setCurrentSegmentIndex(timelineState.currentSegmentIndex || 0);\n\n      // Also set the time range\n      if (timelineState.timelineStartHour !== undefined) {\n        setStartHour(timelineState.timelineStartHour);\n      }\n      if (timelineState.timelineEndHour !== undefined) {\n        setEndHour(timelineState.timelineEndHour);\n      }\n\n      lastSegmentsUpdateRef.current = Date.now();\n    }\n\n    return () => unsubscribe();\n  }, []);\n\n  // Set up drag handling\n  useEffect(() => {\n    const container = containerRef.current;\n    if (!container) return;\n\n    const handleMouseDown = (e) => {\n      // Only handle clicks on the container itself, not on segments\n      if (e.target === container || e.target.classList.contains('timeline-clickable-area')) {\n        isDragging.current = true;\n        handleTimelineClick(e);\n\n        // Add event listeners for drag\n        document.addEventListener('mousemove', handleMouseMove);\n        document.addEventListener('mouseup', handleMouseUp);\n      }\n    };\n\n    const handleMouseMove = (e) => {\n      if (!isDragging.current) return;\n      handleTimelineClick(e);\n    };\n\n    const handleMouseUp = () => {\n      isDragging.current = false;\n      document.removeEventListener('mousemove', handleMouseMove);\n      document.removeEventListener('mouseup', handleMouseUp);\n    };\n\n    container.addEventListener('mousedown', handleMouseDown);\n\n    return () => {\n      container.removeEventListener('mousedown', handleMouseDown);\n      document.removeEventListener('mousemove', handleMouseMove);\n      document.removeEventListener('mouseup', handleMouseUp);\n    };\n  }, [startHour, endHour, segments]);\n\n  // Handle click on timeline for seeking\n  const handleTimelineClick = (event) => {\n    const container = containerRef.current;\n    if (!container) return;\n\n    // Get click position relative to container\n    const rect = container.getBoundingClientRect();\n    const clickX = event.clientX - rect.left;\n    const containerWidth = rect.width;\n\n    // Calculate time based on click position\n    const clickPercent = clickX / containerWidth;\n    const clickHour = startHour + (clickPercent * (endHour - startHour));\n\n    // Find the segment that contains this time\n    const clickDate = new Date(timelineState.selectedDate);\n    clickDate.setHours(Math.floor(clickHour));\n    clickDate.setMinutes(Math.floor((clickHour % 1) * 60));\n    clickDate.setSeconds(Math.floor(((clickHour % 1) * 60) % 1 * 60));\n\n    const clickTimestamp = clickDate.getTime() / 1000;\n\n    // Always update the current time to where the user clicked\n    // This allows the user to position the cursor anywhere on the timeline\n    timelineState.setState({\n      currentTime: clickTimestamp,\n      prevCurrentTime: timelineState.currentTime,\n      // Don't automatically start playing\n      isPlaying: false\n    });\n\n    // Find segment that contains this timestamp\n    let foundSegment = false;\n    for (let i = 0; i < segments.length; i++) {\n      const segment = segments[i];\n      // Use local timestamps if available, otherwise fall back to regular timestamps\n      const startTimestamp = segment.local_start_timestamp || segment.start_timestamp;\n      const endTimestamp = segment.local_end_timestamp || segment.end_timestamp;\n\n      if (clickTimestamp >= startTimestamp && clickTimestamp <= endTimestamp) {\n        console.log(`TimelineSegments: Found segment ${i} containing timestamp`);\n\n        // Update current segment index without starting playback\n        timelineState.setState({\n          currentSegmentIndex: i\n        });\n\n        // Only if the user clicked directly on a segment (not the background),\n        // play that segment starting at the clicked time\n        if (event.target.classList.contains('timeline-segment')) {\n          // Calculate relative time within the segment\n          const relativeTime = clickTimestamp - startTimestamp;\n\n          // Play this segment starting at the clicked time\n          playSegment(i, relativeTime);\n        }\n\n        foundSegment = true;\n        break;\n      }\n    }\n\n    if (!foundSegment) {\n      // If no segment found, don't automatically jump to a different segment\n      // Just leave the cursor where the user clicked\n      timelineState.setState({\n        currentSegmentIndex: -1\n      });\n    }\n  };\n\n  // Play a specific segment\n  const playSegment = (index, relativeTime = null) => {\n    console.log(`TimelineSegments: playSegment(${index}, ${relativeTime})`);\n\n    if (index < 0 || index >= segments.length) {\n      console.warn(`TimelineSegments: Invalid segment index: ${index}`);\n      return;\n    }\n\n    const segment = segments[index];\n\n    // Use local timestamps if available, otherwise fall back to regular timestamps\n    const startTimestamp = segment.local_start_timestamp || segment.start_timestamp;\n\n    // Calculate absolute timestamp for currentTime\n    const absoluteTime = relativeTime !== null\n      ? startTimestamp + relativeTime\n      : startTimestamp;\n\n    // First, pause any current playback and reset the segment index\n    timelineState.setState({\n      isPlaying: false,\n      currentSegmentIndex: -1\n    });\n\n    // Force a synchronous DOM update\n    document.body.offsetHeight;\n\n    // Now set the new segment index and start playing\n    setTimeout(() => {\n      timelineState.setState({\n        currentSegmentIndex: index,\n        currentTime: absoluteTime,\n        isPlaying: true,\n        forceReload: true\n      });\n\n      // Force the video player to reload\n      setTimeout(() => {\n        const videoElement = document.querySelector('#video-player video');\n        if (videoElement) {\n          // Pause any current playback\n          videoElement.pause();\n\n          // Clear the source and reload\n          videoElement.removeAttribute('src');\n          videoElement.load();\n\n          // Set the new source\n          videoElement.src = `/api/recordings/play/${segment.id}?t=${Date.now()}`;\n\n          // Set the current time and play\n          videoElement.onloadedmetadata = () => {\n            const seekTime = relativeTime !== null ? relativeTime : 0;\n            videoElement.currentTime = seekTime;\n            videoElement.play().catch(e => console.error('Error playing video:', e));\n          };\n        }\n      }, 50);\n    }, 50);\n  };\n\n  // Render segments\n  const renderSegments = () => {\n    console.log('TimelineSegments: renderSegments called');\n    console.log('TimelineSegments: segments:', segments);\n    console.log('TimelineSegments: startHour:', startHour, 'endHour:', endHour);\n\n    if (!segments || segments.length === 0) {\n      console.log('TimelineSegments: No segments to render');\n      return html`<div class=\"text-center text-red-500 font-bold\">No segments to display</div>`;\n    }\n\n    console.log('TimelineSegments: Rendering segments:', segments.length);\n\n    const visibleSegments = [];\n    const hourMap = new Map();\n\n    // First pass: collect all segments by hour\n    console.log('TimelineSegments: Starting to process segments');\n    let visibleCount = 0;\n    let skippedCount = 0;\n\n    segments.forEach((segment, index) => {\n      // Always use regular timestamps for consistency\n      const startTimestamp = segment.start_timestamp;\n      const endTimestamp = segment.end_timestamp;\n\n      // Convert timestamps to Date objects\n      const startTime = new Date(startTimestamp * 1000);\n      const endTime = new Date(endTimestamp * 1000);\n\n      // Calculate position and width\n      const startHourFloat = startTime.getHours() + (startTime.getMinutes() / 60) + (startTime.getSeconds() / 3600);\n      const endHourFloat = endTime.getHours() + (endTime.getMinutes() / 60) + (endTime.getSeconds() / 3600);\n\n      // Skip segments outside the visible range\n      if (endHourFloat < startHour || startHourFloat > endHour) {\n        skippedCount++;\n        if (index < 5) {\n          console.log(`TimelineSegments: Skipping segment ${index}, startHour=${startHourFloat}, endHour=${endHourFloat}, visible range=${startHour}-${endHour}`);\n        }\n        return;\n      }\n      visibleCount++;\n\n      // Mark each hour that this segment spans\n      const startFloorHour = Math.floor(startHourFloat);\n      const endCeilHour = Math.min(Math.ceil(endHourFloat), 24);\n\n      for (let h = startFloorHour; h < endCeilHour; h++) {\n        if (h >= startHour && h <= endHour) {\n          if (!hourMap.has(h)) {\n            hourMap.set(h, []);\n          }\n          hourMap.get(h).push(index);\n        }\n      }\n    });\n\n    // Preprocess segments to merge adjacent ones\n    const mergedSegments = [];\n    let currentMergedSegment = null;\n\n    // Sort segments by start time\n    const sortedSegments = [...segments].sort((a, b) => {\n      return a.start_timestamp - b.start_timestamp;\n    });\n\n    // Merge adjacent segments (no gap or very small gap)\n    sortedSegments.forEach((segment, index) => {\n      if (!currentMergedSegment) {\n        // First segment\n        currentMergedSegment = { ...segment, originalIndices: [index] };\n      } else {\n        // Check if this segment is adjacent to the current merged segment\n        const segmentStart = segment.start_timestamp;\n        const mergedEnd = currentMergedSegment.end_timestamp;\n\n        // Allow a small gap (1 second) to account for rounding errors\n        const gap = segmentStart - mergedEnd;\n\n        if (gap <= 1) {\n          // Merge with current segment\n          currentMergedSegment.end_timestamp = segment.end_timestamp;\n          currentMergedSegment.originalIndices.push(index);\n\n          // If this segment has detection, mark the merged segment as having detection\n          if (segment.has_detection) {\n            currentMergedSegment.has_detection = true;\n          }\n        } else {\n          // Gap is too large, start a new merged segment\n          mergedSegments.push(currentMergedSegment);\n          currentMergedSegment = { ...segment, originalIndices: [index] };\n        }\n      }\n    });\n\n    // Add the last merged segment\n    if (currentMergedSegment) {\n      mergedSegments.push(currentMergedSegment);\n    }\n\n    // Second pass: add visible segments\n    mergedSegments.forEach((segment, mergedIndex) => {\n      const segStartTimestamp = segment.start_timestamp;\n      const segEndTimestamp = segment.end_timestamp;\n\n      // Convert timestamps to timeline hours using the utility function\n      const startHourFloat = timelineState.timestampToTimelineHour(segStartTimestamp);\n      const endHourFloat = timelineState.timestampToTimelineHour(segEndTimestamp);\n\n      // Log the timestamps and hours for debugging\n      console.log('TimelineSegments: Segment timestamps', {\n        segmentId: segment.id,\n        startTimestamp: segStartTimestamp,\n        endTimestamp: segEndTimestamp,\n        startTimeLocal: new Date(segStartTimestamp * 1000).toLocaleString(),\n        endTimeLocal: new Date(segEndTimestamp * 1000).toLocaleString(),\n        startHourFloat,\n        endHourFloat\n      });\n\n      // Skip segments outside the visible range\n      if (endHourFloat < startHour || startHourFloat > endHour) {\n        return;\n      }\n\n      // Adjust start and end to fit within visible range\n      const visibleStartHour = Math.max(startHourFloat, startHour);\n      const visibleEndHour = Math.min(endHourFloat, endHour);\n\n      // Calculate position and width as percentages\n      const startPercent = ((visibleStartHour - startHour) / (endHour - startHour)) * 100;\n      const widthPercent = ((visibleEndHour - visibleStartHour) / (endHour - startHour)) * 100;\n\n      // Format duration for tooltip\n      const duration = Math.round(segEndTimestamp - segStartTimestamp);\n      const durationStr = `${duration}s`;\n\n      // Format times for tooltip\n      const startTimeStr = new Date(segStartTimestamp * 1000).toLocaleTimeString();\n      const endTimeStr = new Date(segEndTimestamp * 1000).toLocaleTimeString();\n\n      // Use a consistent height for all segments\n      const heightPercent = 80; // 80% height for all segments\n\n      visibleSegments.push(\n        <div\n          key={`segment-${mergedIndex}`}\n          className={`timeline-segment absolute rounded-sm transition-all duration-200 ${segment.has_detection ? 'bg-red-500' : 'bg-blue-500'}`}\n          style={{\n            left: `${startPercent}%`,\n            width: `${widthPercent}%`,\n            height: `${heightPercent}%`,\n            top: '50%',\n            transform: 'translateY(-50%)'\n          }}\n          title={`${startTimeStr} - ${endTimeStr} (${durationStr})`}\n        ></div>\n      );\n    });\n\n    // Third pass: fill in gaps with clickable areas\n    for (let hour = Math.floor(startHour); hour < Math.ceil(endHour); hour++) {\n      if (!hourMap.has(hour)) {\n        // No segments in this hour, create a clickable area\n        const position = ((hour - startHour) / (endHour - startHour)) * 100;\n        const width = 100 / (endHour - startHour);\n\n        visibleSegments.push(\n          <div\n            key={`clickable-${hour}`}\n            className=\"timeline-clickable-area absolute h-full cursor-pointer\"\n            style={{\n              left: `${position}%`,\n              width: `${width}%`\n            }}\n            data-hour={hour}\n          ></div>\n        );\n      }\n    }\n\n    console.log(`TimelineSegments: Rendering complete. Total: ${segments.length}, Visible: ${visibleCount}, Skipped: ${skippedCount}, Final rendered: ${visibleSegments.length}`);\n    return visibleSegments;\n  };\n\n  return (\n    <div\n      className=\"timeline-segments relative w-full h-16 pt-2\"\n      ref={containerRef}\n    >\n      {renderSegments()}\n    </div>\n  );\n}\n","/**\n * LightNVR Timeline Cursor Component\n * Displays the playback cursor on the timeline\n */\n\nimport { useState, useEffect, useRef } from 'preact/hooks';\nimport { timelineState } from './TimelinePage.jsx';\n\n/**\n * TimelineCursor component\n * @returns {JSX.Element} TimelineCursor component\n */\nexport function TimelineCursor() {\n  // Local state\n  const [position, setPosition] = useState(0);\n  const [visible, setVisible] = useState(false);\n  const [startHour, setStartHour] = useState(0);\n  const [endHour, setEndHour] = useState(24);\n  const [currentTime, setCurrentTime] = useState(null);\n  const [isDragging, setIsDragging] = useState(false);\n\n  // Refs\n  const cursorRef = useRef(null);\n  const containerRef = useRef(null);\n  const dragStartXRef = useRef(0);\n\n  // Debounce function to limit how often a function can be called\n  const debounce = (func, delay) => {\n    let timeoutId;\n    return function(...args) {\n      if (timeoutId) {\n        clearTimeout(timeoutId);\n      }\n      timeoutId = setTimeout(() => {\n        func.apply(this, args);\n      }, delay);\n    };\n  };\n\n  // Create debounced version of updateCursorPosition\n  const debouncedUpdateCursorPosition = useRef(\n    debounce((time, startHr, endHr) => {\n      updateCursorPosition(time, startHr, endHr);\n    }, 100)\n  ).current;\n\n  // Subscribe to timeline state changes\n  useEffect(() => {\n    const unsubscribe = timelineState.subscribe(state => {\n      console.log('TimelineCursor: State update received', {\n        currentTime: state.currentTime,\n        startHour: state.timelineStartHour,\n        endHour: state.timelineEndHour,\n        segmentsCount: state.timelineSegments ? state.timelineSegments.length : 0,\n        isDragging: isDragging,\n        userControllingCursor: state.userControllingCursor\n      });\n\n      // Update local state\n      setStartHour(state.timelineStartHour || 0);\n      setEndHour(state.timelineEndHour || 24);\n\n      // Only update current time if not dragging\n      if (!isDragging && !state.userControllingCursor) {\n        setCurrentTime(state.currentTime);\n        updateTimeDisplay(state.currentTime);\n\n        // Use debounced update for smoother performance\n        debouncedUpdateCursorPosition(state.currentTime, state.timelineStartHour || 0, state.timelineEndHour || 24);\n      }\n    });\n\n    return () => unsubscribe();\n  }, [isDragging, debouncedUpdateCursorPosition]);\n\n  // Set up drag handling\n  useEffect(() => {\n    const cursor = cursorRef.current;\n    if (!cursor) return;\n\n    const handleMouseDown = (e) => {\n      e.preventDefault();\n      e.stopPropagation();\n\n      console.log('TimelineCursor: Mouse down event');\n\n      // Store the starting X position\n      dragStartXRef.current = e.clientX;\n\n      // Set dragging state\n      setIsDragging(true);\n\n      // Set global flags to prevent other components from updating cursor\n      timelineState.userControllingCursor = true;\n      timelineState.preserveCursorPosition = true;\n      timelineState.cursorPositionLocked = true;\n      timelineState.setState({});\n\n      // Add event listeners for drag\n      document.addEventListener('mousemove', handleMouseMove);\n      document.addEventListener('mouseup', handleMouseUp);\n    };\n\n    const handleMouseMove = (e) => {\n      if (!isDragging) return;\n\n      // Get container dimensions\n      const container = cursor.parentElement;\n      if (!container) return;\n\n      const rect = container.getBoundingClientRect();\n      const clickX = Math.max(0, Math.min(e.clientX - rect.left, rect.width));\n      const containerWidth = rect.width;\n\n      // Calculate position as percentage\n      const positionPercent = (clickX / containerWidth) * 100;\n      setPosition(positionPercent);\n\n      // Calculate time based on position\n      const hourRange = endHour - startHour;\n      const hour = startHour + (positionPercent / 100) * hourRange;\n\n      // Convert hour to timestamp using the utility function\n      const timestamp = timelineState.timelineHourToTimestamp(hour, timelineState.selectedDate);\n\n      // Store the current time locally but don't update the global state yet\n      setCurrentTime(timestamp);\n\n      // Update time display\n      updateTimeDisplay(timestamp);\n    };\n\n    const handleMouseUp = (e) => {\n      if (!isDragging) return;\n\n      // Get container dimensions\n      const container = cursor.parentElement;\n      if (!container) return;\n\n      const rect = container.getBoundingClientRect();\n      const clickX = Math.max(0, Math.min(e.clientX - rect.left, rect.width));\n      const containerWidth = rect.width;\n\n      // Calculate position as percentage\n      const positionPercent = (clickX / containerWidth) * 100;\n      console.log('TimelineCursor: Mouse up at position', { positionPercent, clickX, containerWidth });\n\n      // Calculate time based on position\n      const hourRange = endHour - startHour;\n      const hour = startHour + (positionPercent / 100) * hourRange;\n      console.log('TimelineCursor: Calculated hour', { hour, startHour, endHour, hourRange });\n\n      // Convert hour to timestamp using the utility function\n      const timestamp = timelineState.timelineHourToTimestamp(hour, timelineState.selectedDate);\n\n      console.log('TimelineCursor: Converted hour to timestamp', {\n        hour,\n        localDate: new Date(timestamp * 1000).toLocaleString(),\n        timestamp\n      });\n      console.log('TimelineCursor: Converted to timestamp', {\n        timestamp,\n        dateTime: new Date(timestamp * 1000).toLocaleString(),\n        selectedDate: timelineState.selectedDate\n      });\n\n      console.log('TimelineCursor: Mouse up event');\n\n      // Reset dragging state FIRST\n      setIsDragging(false);\n\n      // Remove event listeners\n      document.removeEventListener('mousemove', handleMouseMove);\n      document.removeEventListener('mouseup', handleMouseUp);\n\n      // Reset some flags but keep preserveCursorPosition true\n      // This allows the current update to complete before other components can update the cursor\n      setTimeout(() => {\n        console.log('TimelineCursor: Releasing cursor control but preserving position');\n        timelineState.userControllingCursor = false;\n        // Keep preserveCursorPosition true to prevent position resets\n        // Keep cursorPositionLocked true to prevent automatic updates\n        timelineState.setState({});\n      }, 100);\n\n      // Always update the current time to where the user placed the cursor\n      // This allows the user to position the cursor anywhere on the timeline\n      timelineState.currentTime = timestamp;\n\n      // Add a small buffer to prevent cursor from snapping to segment start\n      // This is especially important for positions near the beginning of segments\n      if (timelineState.timelineSegments && timelineState.timelineSegments.length > 0) {\n        // Find the segment that contains this timestamp\n        const segment = timelineState.timelineSegments.find(seg =>\n          timestamp >= seg.start_timestamp && timestamp <= seg.end_timestamp\n        );\n\n        if (segment) {\n          // If we're very close to the start of the segment (within 1 second),\n          // add a small offset to prevent snapping to the start\n          const distanceFromStart = timestamp - segment.start_timestamp;\n          if (distanceFromStart < 1.0) {\n            // Add a small offset (0.5 seconds) to prevent snapping to start\n            const adjustedTime = segment.start_timestamp + 1.0;\n            console.log(`TimelineCursor: Adjusting cursor position from ${timestamp} to ${adjustedTime} to prevent snapping to segment start`);\n            timelineState.currentTime = adjustedTime;\n          }\n        }\n      }\n      timelineState.prevCurrentTime = timelineState.currentTime;\n      timelineState.isPlaying = false;\n\n      // Notify listeners\n      timelineState.setState({});\n\n      // Find segment that contains this timestamp\n      const segments = timelineState.timelineSegments || [];\n      console.log('TimelineCursor: Searching for segment containing timestamp', {\n        timestamp,\n        segmentsCount: segments.length\n      });\n\n      let foundSegment = false;\n      let closestSegment = -1;\n      let minDistance = Infinity;\n\n      // First try to find an exact match\n      for (let i = 0; i < segments.length; i++) {\n        const segment = segments[i];\n        // Use local timestamps if available, otherwise fall back to regular timestamps\n        const startTimestamp = segment.local_start_timestamp || segment.start_timestamp;\n        const endTimestamp = segment.local_end_timestamp || segment.end_timestamp;\n\n        // Log the first few segments for debugging\n        if (i < 3) {\n          console.log(`TimelineCursor: Segment ${i}`, {\n            startTimestamp,\n            endTimestamp,\n            startTime: new Date(startTimestamp * 1000).toLocaleTimeString(),\n            endTime: new Date(endTimestamp * 1000).toLocaleTimeString()\n          });\n        }\n\n        // Check if timestamp is within this segment\n        if (timestamp >= startTimestamp && timestamp <= endTimestamp) {\n          console.log(`TimelineCursor: Found exact match at segment ${i}`);\n          // Update current segment index without changing the time or starting playback\n          timelineState.currentSegmentIndex = i;\n          timelineState.setState({});\n          foundSegment = true;\n          break;\n        }\n\n        // Calculate distance to this segment (for finding closest if no exact match)\n        const midpoint = (startTimestamp + endTimestamp) / 2;\n        const distance = Math.abs(timestamp - midpoint);\n        if (distance < minDistance) {\n          minDistance = distance;\n          closestSegment = i;\n        }\n      }\n\n      // If no exact match found, use the closest segment\n      if (!foundSegment) {\n        if (closestSegment >= 0) {\n          console.log(`TimelineCursor: No exact match, using closest segment ${closestSegment}`);\n          timelineState.currentSegmentIndex = closestSegment;\n          timelineState.setState({});\n        } else {\n          console.log('TimelineCursor: No segments found at all');\n          // Reset current segment index\n          timelineState.currentSegmentIndex = -1;\n          timelineState.setState({});\n        }\n      }\n    };\n\n    // Add event listeners\n    cursor.addEventListener('mousedown', handleMouseDown);\n\n    return () => {\n      cursor.removeEventListener('mousedown', handleMouseDown);\n      document.removeEventListener('mousemove', handleMouseMove);\n      document.removeEventListener('mouseup', handleMouseUp);\n    };\n  }, [cursorRef.current, startHour, endHour, isDragging]);\n\n  // Update cursor position\n  const updateCursorPosition = (time, startHr, endHr) => {\n    console.log('TimelineCursor: updateCursorPosition called', { time, startHr, endHr });\n\n    if (time === null) {\n      console.log('TimelineCursor: No current time, hiding cursor');\n      setVisible(false);\n      return;\n    }\n\n    // Calculate cursor position\n    const date = new Date(time * 1000);\n    const hour = date.getHours() + (date.getMinutes() / 60) + (date.getSeconds() / 3600);\n    console.log('TimelineCursor: Calculated hour', { hour, timeString: date.toLocaleTimeString() });\n\n    // Check if the current time is within the visible range\n    if (hour < startHr || hour > endHr) {\n      console.log('TimelineCursor: Time outside visible range, hiding cursor');\n      setVisible(false);\n      return;\n    }\n\n    // Calculate position as percentage\n    const position = ((hour - startHr) / (endHr - startHr)) * 100;\n    console.log('TimelineCursor: Calculated position', { position, hour, startHr, endHr });\n\n    // Update cursor position\n    setPosition(position);\n    setVisible(true);\n  };\n\n  // Update time display\n  const updateTimeDisplay = (time) => {\n    if (time === null) return;\n\n    const timeDisplay = document.getElementById('time-display');\n    if (!timeDisplay) return;\n\n    const date = new Date(time * 1000);\n\n    // Format date and time\n    const hours = date.getHours().toString().padStart(2, '0');\n    const minutes = date.getMinutes().toString().padStart(2, '0');\n    const seconds = date.getSeconds().toString().padStart(2, '0');\n\n    // Display time only (HH:MM:SS)\n    timeDisplay.textContent = `${hours}:${minutes}:${seconds}`;\n  };\n\n  // Force the cursor to be visible on initial render\n  useEffect(() => {\n    console.log('TimelineCursor: Initializing cursor position');\n    console.log('TimelineCursor: Initial state', {\n      currentTime: timelineState.currentTime,\n      startHour: timelineState.timelineStartHour,\n      endHour: timelineState.timelineEndHour,\n      segments: timelineState.timelineSegments ? timelineState.timelineSegments.length : 0\n    });\n\n    // Function to initialize cursor\n    const initCursor = () => {\n      console.log('TimelineCursor: Checking timelineState directly', {\n        currentTime: timelineState.currentTime,\n        segmentsLength: timelineState.timelineSegments ? timelineState.timelineSegments.length : 0,\n        currentSegmentIndex: timelineState.currentSegmentIndex\n      });\n\n      if (timelineState.currentTime) {\n        console.log('TimelineCursor: Setting initial cursor position with current time');\n        setVisible(true);\n        updateCursorPosition(\n          timelineState.currentTime,\n          timelineState.timelineStartHour || 0,\n          timelineState.timelineEndHour || 24\n        );\n        return true;\n      } else if (timelineState.timelineSegments && timelineState.timelineSegments.length > 0) {\n        // If no current time but we have segments, use the first segment's start time\n        console.log('TimelineCursor: Using first segment start time for cursor');\n        const firstSegment = timelineState.timelineSegments[0];\n        const segmentStartTime = firstSegment.start_timestamp;\n\n        // Update the timeline state with this time - DIRECT ASSIGNMENT\n        console.log('TimelineCursor: Directly setting timelineState properties');\n        timelineState.currentTime = segmentStartTime;\n        timelineState.currentSegmentIndex = 0;\n\n        // Now call setState to notify listeners\n        timelineState.setState({\n          // Empty object just to trigger notification\n        });\n\n        setVisible(true);\n        updateCursorPosition(\n          segmentStartTime,\n          timelineState.timelineStartHour || 0,\n          timelineState.timelineEndHour || 24\n        );\n        return true;\n      }\n      return false;\n    };\n\n    // Try to initialize immediately\n    const initialized = initCursor();\n\n    // If not initialized, try again after a delay\n    if (!initialized) {\n      console.log('TimelineCursor: Initial initialization failed, will retry after delay');\n\n      // Set up multiple attempts with increasing delays\n      const delays = [100, 300, 500, 1000];\n\n      delays.forEach((delay, index) => {\n        setTimeout(() => {\n          if (!visible) {\n            console.log(`TimelineCursor: Retry initialization attempt ${index + 1}`);\n            initCursor();\n          }\n        }, delay);\n      });\n    }\n  }, []);\n\n  return (\n    <div\n      ref={cursorRef}\n      className=\"timeline-cursor absolute top-0 h-full z-50 transition-all duration-100 cursor-ew-resize\"\n      style={{\n        left: `${position}%`,\n        display: visible ? 'block' : 'none',\n        pointerEvents: 'auto',\n        width: '7px',\n        marginLeft: '-3.5px'\n      }}\n    >\n      {/* Invisible wider clickable area */}\n      <div className=\"absolute top-0 bottom-0 left-0 w-full\"></div>\n\n      {/* Skinnier needle with no middle chunk */}\n      <div className=\"absolute top-0 bottom-0 w-0.5 bg-orange-500 left-1/2 transform -translate-x-1/2 pointer-events-none\"></div>\n\n      {/* Top handle (black) */}\n      <div className=\"absolute top-0 left-1/2 w-4 h-4 bg-black rounded-full transform -translate-x-1/2 -translate-y-1/2 shadow-md pointer-events-none\"></div>\n\n      {/* Bottom handle (black) */}\n      <div className=\"absolute bottom-0 left-1/2 w-4 h-4 bg-black rounded-full transform -translate-x-1/2 translate-y-1/2 shadow-md pointer-events-none\"></div>\n    </div>\n  );\n}\n","/**\n * LightNVR Speed Controls Component\n * Handles playback speed controls for the timeline\n */\n\nimport { useState, useEffect } from 'preact/hooks';\nimport { timelineState } from './TimelinePage.jsx';\nimport { showStatusMessage } from '../ToastContainer.jsx';\n\n/**\n * SpeedControls component\n * @returns {JSX.Element} SpeedControls component\n */\nexport function SpeedControls() {\n  // Local state\n  const [currentSpeed, setCurrentSpeed] = useState(1.0);\n\n  // Available speeds\n  const speeds = [0.25, 0.5, 1.0, 1.5, 2.0, 4.0];\n\n  // Subscribe to timeline state changes\n  useEffect(() => {\n    const unsubscribe = timelineState.subscribe(state => {\n      setCurrentSpeed(state.playbackSpeed);\n    });\n\n    return () => unsubscribe();\n  }, []);\n\n  // Set playback speed\n  const setPlaybackSpeed = (speed) => {\n    // Update video playback rate\n    const videoPlayer = document.querySelector('#video-player video');\n    if (videoPlayer) {\n      // Set the new playback rate\n      videoPlayer.playbackRate = speed;\n    }\n\n    // Update timeline state\n    timelineState.setState({ playbackSpeed: speed });\n\n    // Show status message\n    showStatusMessage(`Playback speed: ${speed}x`, 'info');\n  };\n\n  return (\n    <div className=\"mt-2 mb-4 p-2 border border-green-500 rounded-lg bg-white dark:bg-gray-800 shadow-sm\">\n      <div className=\"flex flex-col items-center\">\n        <div className=\"text-sm font-semibold mb-2 text-gray-700 dark:text-gray-300\">Playback Speed</div>\n\n        <div className=\"flex flex-wrap justify-center gap-1\">\n          {speeds.map(speed => (\n            <button\n              key={`speed-${speed}`}\n              className={`speed-btn px-2 py-1 text-sm rounded-full ${speed === currentSpeed\n                ? 'bg-green-500 text-white'\n                : 'bg-gray-200 hover:bg-gray-300 dark:bg-gray-700 dark:text-gray-200 dark:hover:bg-gray-600'}\n                font-medium transition-all focus:outline-none focus:ring-1 focus:ring-green-500 focus:ring-opacity-50`}\n              data-speed={speed}\n              onClick={() => setPlaybackSpeed(speed)}\n            >\n              {speed === 1.0 ? '1 (Normal)' : `${speed}`}\n            </button>\n          ))}\n        </div>\n\n        <div className=\"mt-1 text-xs font-medium text-green-600 dark:text-green-400\">\n          Current: {currentSpeed} {currentSpeed === 1.0 ? '(Normal)' : ''}\n        </div>\n      </div>\n    </div>\n  );\n}\n","/**\n * LightNVR Timeline Player Component\n * Handles video playback for the timeline\n */\n\nimport { useState, useEffect, useRef } from 'preact/hooks';\nimport { timelineState } from './TimelinePage.jsx';\nimport { SpeedControls } from './SpeedControls.jsx';\nimport { showStatusMessage } from '../ToastContainer.jsx';\n\n/**\n * TimelinePlayer component\n * @returns {JSX.Element} TimelinePlayer component\n */\nexport function TimelinePlayer() {\n  // Local state\n  const [currentSegmentIndex, setCurrentSegmentIndex] = useState(-1);\n  const [isPlaying, setIsPlaying] = useState(false);\n  const [segments, setSegments] = useState([]);\n  const [playbackSpeed, setPlaybackSpeed] = useState(1.0);\n\n  // Refs\n  const videoRef = useRef(null);\n  const lastTimeUpdateRef = useRef(null);\n  const lastSegmentIdRef = useRef(null);\n\n  // Subscribe to timeline state changes\n  useEffect(() => {\n    const unsubscribe = timelineState.subscribe(state => {\n      // Update local state\n      setCurrentSegmentIndex(state.currentSegmentIndex);\n      setIsPlaying(state.isPlaying);\n      setSegments(state.timelineSegments || []);\n      setPlaybackSpeed(state.playbackSpeed);\n\n      // Handle video playback\n      handleVideoPlayback(state);\n    });\n\n    return () => unsubscribe();\n  }, []);\n\n  // Handle video playback based on state changes\n  const handleVideoPlayback = (state) => {\n    const video = videoRef.current;\n    if (!video) return;\n\n    // Check if we have valid segments and segment index\n    if (!state.timelineSegments ||\n        state.timelineSegments.length === 0 ||\n        state.currentSegmentIndex < 0 ||\n        state.currentSegmentIndex >= state.timelineSegments.length) {\n      return;\n    }\n\n    // Get current segment\n    const segment = state.timelineSegments[state.currentSegmentIndex];\n    if (!segment) return;\n\n    // Check if we need to load a new segment\n    const segmentChanged = lastSegmentIdRef.current !== segment.id;\n\n    // IMPORTANT: Only reload if the segment has actually changed\n    // This prevents constant reloading\n    const needsReload = segmentChanged;\n\n    // Calculate relative time within the segment\n    let relativeTime = 0;\n\n    if (state.currentTime !== null) {\n      if (state.currentTime >= segment.start_timestamp && state.currentTime <= segment.end_timestamp) {\n        // If current time is within this segment, calculate the relative position\n        relativeTime = state.currentTime - segment.start_timestamp;\n        console.log(`Current time ${state.currentTime} is within segment ${segment.id}, relative time: ${relativeTime}s`);\n      } else if (state.currentTime < segment.start_timestamp) {\n        // If current time is before this segment, start at the beginning\n        relativeTime = 0;\n        console.log(`Current time ${state.currentTime} is before segment ${segment.id}, starting at beginning`);\n      } else {\n        // If current time is after this segment, start at the end\n        relativeTime = segment.end_timestamp - segment.start_timestamp;\n        console.log(`Current time ${state.currentTime} is after segment ${segment.id}, starting at end`);\n      }\n    }\n\n    // Only update the video if:\n    // 1. We need to load a new segment, OR\n    // 2. The user is dragging the cursor (indicated by a significant time change)\n    const timeChanged = state.prevCurrentTime !== null &&\n                        Math.abs(state.currentTime - state.prevCurrentTime) > 1;\n\n    // Update last segment ID\n    if (segmentChanged) {\n      console.log(`Segment changed from ${lastSegmentIdRef.current} to ${segment.id}`);\n      lastSegmentIdRef.current = segment.id;\n    }\n\n    // Handle playback\n    if (needsReload) {\n      // Load new segment\n      console.log(`Loading new segment ${segment.id} (segmentChanged: ${segmentChanged})`);\n      loadSegment(segment, relativeTime, state.isPlaying);\n    } else if (timeChanged) {\n      // User is dragging the cursor, just update the current time\n      console.log(`Seeking to ${relativeTime}s within current segment`);\n      video.currentTime = relativeTime;\n    } else if (state.isPlaying && video.paused) {\n      // Resume playback if needed\n      video.play().catch(error => {\n        console.error('Error playing video:', error);\n      });\n    } else if (!state.isPlaying && !video.paused) {\n      // Pause playback if needed\n      video.pause();\n    }\n\n    // Update playback speed if needed\n    if (video.playbackRate !== state.playbackSpeed) {\n      video.playbackRate = state.playbackSpeed;\n    }\n  };\n\n  // Load a segment\n  const loadSegment = (segment, seekTime = 0, autoplay = false) => {\n    const video = videoRef.current;\n    if (!video) return;\n\n    console.log(`Loading segment ${segment.id} at time ${seekTime}s, autoplay: ${autoplay}`);\n\n    // Pause current playback\n    video.pause();\n\n    // Set new source with timestamp to prevent caching\n    const recordingUrl = `/api/recordings/play/${segment.id}?t=${Date.now()}`;\n\n    // Set up event listeners for the new video\n    const onLoadedMetadata = () => {\n      console.log('Video metadata loaded');\n\n      // Check if the current time is within this segment\n      // If so, use the relative position from the cursor\n      let timeToSet = seekTime;\n\n      // Check if we should preserve the cursor position\n      if (timelineState.preserveCursorPosition && timelineState.currentTime !== null) {\n        // Calculate the relative time within the segment\n        if (timelineState.currentTime >= segment.start_timestamp &&\n            timelineState.currentTime <= segment.end_timestamp) {\n          // If the cursor is within this segment, use its position\n          timeToSet = timelineState.currentTime - segment.start_timestamp;\n          console.log(`TimelinePlayer: Using locked cursor position for playback: ${timeToSet}s`);\n        } else {\n          // If the cursor is outside this segment but we want to preserve its position,\n          // use the beginning or end of the segment based on which is closer\n          const distanceToStart = Math.abs(timelineState.currentTime - segment.start_timestamp);\n          const distanceToEnd = Math.abs(timelineState.currentTime - segment.end_timestamp);\n\n          if (distanceToStart <= distanceToEnd) {\n            timeToSet = 0; // Use start of segment\n            console.log(`TimelinePlayer: Cursor outside segment, using start of segment`);\n          } else {\n            timeToSet = segment.end_timestamp - segment.start_timestamp; // Use end of segment\n            console.log(`TimelinePlayer: Cursor outside segment, using end of segment`);\n          }\n        }\n      } else if (timelineState.currentTime !== null &&\n                 timelineState.currentTime >= segment.start_timestamp &&\n                 timelineState.currentTime <= segment.end_timestamp) {\n        // If not preserving cursor position but the current time is within this segment,\n        // still use the relative position from the cursor\n        timeToSet = timelineState.currentTime - segment.start_timestamp;\n        console.log(`TimelinePlayer: Using cursor position for playback: ${timeToSet}s`);\n      }\n\n      // Set current time, ensuring it's within valid bounds\n      const segmentDuration = segment.end_timestamp - segment.start_timestamp;\n\n      // Add a small buffer for positions near the beginning of the segment\n      // This prevents the cursor from snapping to the start\n      let validSeekTime = Math.min(Math.max(0, timeToSet), segmentDuration);\n\n      // If we're very close to the start of the segment but not exactly at the start,\n      // add a small offset to prevent snapping to the start\n      if (validSeekTime > 0 && validSeekTime < 1.0) {\n        // Ensure we're at least 1 second into the segment\n        validSeekTime = 1.0;\n        console.log(`TimelinePlayer: Adjusting seek time to ${validSeekTime}s to prevent snapping to segment start`);\n      }\n\n      console.log(`TimelinePlayer: Setting video time to ${validSeekTime}s (requested: ${timeToSet}s, segment duration: ${segmentDuration}s)`);\n      video.currentTime = validSeekTime;\n\n      // Set playback speed\n      video.playbackRate = playbackSpeed;\n\n      // Play if needed\n      if (autoplay) {\n        video.play().catch(error => {\n          console.error('Error playing video:', error);\n          showStatusMessage('Error playing video: ' + error.message, 'error');\n        });\n      }\n\n      // Remove event listener\n      video.removeEventListener('loadedmetadata', onLoadedMetadata);\n    };\n\n    // Add event listener for metadata loaded\n    video.addEventListener('loadedmetadata', onLoadedMetadata);\n\n    // Set new source\n    video.src = recordingUrl;\n    video.load();\n  };\n\n  // Handle video ended event\n  const handleEnded = () => {\n    console.log('Video ended');\n\n    // Check if we have a next segment\n    if (currentSegmentIndex < segments.length - 1) {\n      // Play next segment\n      const nextIndex = currentSegmentIndex + 1;\n      console.log(`Playing next segment ${nextIndex}`);\n\n      // Store the current cursor position\n      const wasUserControllingCursor = timelineState.userControllingCursor;\n\n      // Set a flag to indicate we're handling the segment transition\n      // This prevents other components from interfering\n      timelineState.directVideoControl = true;\n\n      // Update timeline state\n      timelineState.setState({\n        currentSegmentIndex: nextIndex,\n        // Only set the current time to the start of the next segment if the user wasn't controlling the cursor\n        // This preserves the cursor position if the user had manually positioned it\n        currentTime: wasUserControllingCursor ? timelineState.currentTime : segments[nextIndex].start_timestamp,\n        isPlaying: true,\n        forceReload: true\n      });\n\n      // Reset the directVideoControl flag after a delay\n      setTimeout(() => {\n        timelineState.directVideoControl = false;\n        timelineState.setState({});\n      }, 1000);\n    } else {\n      // End of all segments\n      console.log('End of all segments');\n\n      // Update timeline state\n      timelineState.setState({\n        isPlaying: false\n      });\n    }\n  };\n\n  // Handle video time update event\n  const handleTimeUpdate = () => {\n    const video = videoRef.current;\n    if (!video) return;\n\n    // Check if we have a valid segment\n    if (currentSegmentIndex < 0 ||\n        !segments ||\n        segments.length === 0 ||\n        currentSegmentIndex >= segments.length) {\n      return;\n    }\n\n    const segment = segments[currentSegmentIndex];\n    if (!segment) return;\n\n    // Calculate current timestamp, handling timezone correctly\n    const currentTime = segment.start_timestamp + video.currentTime;\n\n    // Log the current time for debugging\n    console.log('TimelinePlayer: Current time', {\n      videoTime: video.currentTime,\n      segmentStart: segment.start_timestamp,\n      calculatedTime: currentTime,\n      localTime: new Date(currentTime * 1000).toLocaleString()\n    });\n\n    // Directly update the time display as well\n    updateTimeDisplay(currentTime);\n\n    // Check if the user is controlling the cursor\n    // If so, don't update the timeline state to avoid overriding the user's position\n    if (timelineState.userControllingCursor) {\n      console.log('TimelinePlayer: User is controlling cursor, not updating timeline state');\n      return;\n    }\n\n    // Check if cursor position is locked\n    // If so, don't update the timeline state to preserve the cursor position\n    if (timelineState.cursorPositionLocked) {\n      console.log('TimelinePlayer: Cursor position is locked, not updating timeline state');\n      return;\n    }\n\n    // Check if directVideoControl flag is set\n    // If so, don't update the timeline state to avoid conflicts with TimelineControls\n    if (timelineState.directVideoControl) {\n      console.log('TimelinePlayer: Direct video control active, not updating timeline state');\n      return;\n    }\n\n    // Update timeline state with the current time\n    timelineState.setState({\n      currentTime: currentTime,\n      prevCurrentTime: lastTimeUpdateRef.current\n    });\n\n    // Update last time update\n    lastTimeUpdateRef.current = currentTime;\n  };\n\n  // Add a direct time display update function\n  const updateTimeDisplay = (time) => {\n    if (time === null) return;\n\n    const timeDisplay = document.getElementById('time-display');\n    if (!timeDisplay) return;\n\n    // Convert timestamp to timeline hour\n    const hour = timelineState.timestampToTimelineHour(time);\n\n    // Format time\n    const hours = Math.floor(hour).toString().padStart(2, '0');\n    const minutes = Math.floor((hour % 1) * 60).toString().padStart(2, '0');\n    const seconds = Math.floor(((hour % 1) * 60) % 1 * 60).toString().padStart(2, '0');\n\n    // Display time only (HH:MM:SS)\n    timeDisplay.textContent = `${hours}:${minutes}:${seconds}`;\n\n    console.log('TimelinePlayer: Updated time display', {\n      timestamp: time,\n      hour,\n      formatted: `${hours}:${minutes}:${seconds}`,\n      localTime: new Date(time * 1000).toLocaleString()\n    });\n  };\n\n  return (\n    <>\n      <div className=\"timeline-player-container mb-2\" id=\"video-player\">\n        <div className=\"relative w-full bg-black rounded-lg shadow-md\" style={{ aspectRatio: '16/9' }}>\n          <video\n              ref={videoRef}\n              className=\"w-full h-full object-contain\"\n              controls\n              autoPlay={false}\n              muted={false}\n              playsInline\n              onEnded={handleEnded}\n              onTimeUpdate={handleTimeUpdate}\n          ></video>\n\n          {/* Add a message for invalid segments */}\n          <div\n            className={`absolute inset-0 flex items-center justify-center bg-black bg-opacity-70 text-white text-center p-4 ${currentSegmentIndex >= 0 && segments.length > 0 ? 'hidden' : ''}`}\n          >\n            <div>\n              <p className=\"mb-2\">No valid segment selected.</p>\n              <p className=\"text-sm\">Click on a segment in the timeline or use the play button to start playback.</p>\n            </div>\n          </div>\n        </div>\n      </div>\n\n      {/* Playback speed controls */}\n      <SpeedControls />\n    </>\n  );\n}\n","/**\n * LightNVR Timeline Page Component\n * Main component for the timeline view\n */\n\nimport React, { useState, useEffect, useRef } from 'react';\nimport { TimelineControls } from './TimelineControls.jsx';\nimport { TimelineRuler } from './TimelineRuler.jsx';\nimport { TimelineSegments } from './TimelineSegments.jsx';\nimport { TimelineCursor } from './TimelineCursor.jsx';\nimport { TimelinePlayer } from './TimelinePlayer.jsx';\nimport { showStatusMessage } from '../ToastContainer.jsx';\nimport { LoadingIndicator } from '../LoadingIndicator.jsx';\nimport { useQuery } from '../../../query-client.js';\n\n// Utility function to convert between timeline hour and timestamp\nfunction timelineHourToTimestamp(hour, selectedDate) {\n  // Get the selected date or today\n  const date = selectedDate ? new Date(selectedDate) : new Date();\n\n  // Reset time components\n  date.setHours(0, 0, 0, 0);\n\n  // Add the hour component (this is in local time)\n  const milliseconds = date.getTime() + (hour * 60 * 60 * 1000);\n\n  // Convert to timestamp (seconds)\n  return Math.floor(milliseconds / 1000);\n}\n\n// Utility function to convert timestamp to timeline hour\nfunction timestampToTimelineHour(timestamp) {\n  const date = new Date(timestamp * 1000);\n  return date.getHours() + (date.getMinutes() / 60) + (date.getSeconds() / 3600);\n}\n\n// Global timeline state for child components\nconst timelineState = {\n  streams: [],\n  timelineSegments: [],\n  selectedStream: null,\n  selectedDate: null,\n  isPlaying: false,\n  currentSegmentIndex: -1,\n  zoomLevel: 1, // 1 = 1 hour, 2 = 30 minutes, 4 = 15 minutes\n  timelineStartHour: 0,\n  timelineEndHour: 24,\n  currentTime: null,\n  prevCurrentTime: null,\n  playbackSpeed: 1.0,\n  showOnlySegments: true,\n  forceReload: false,\n  userControllingCursor: false, // New flag to track if user is controlling cursor\n  preserveCursorPosition: false, // New flag to explicitly preserve cursor position\n  cursorPositionLocked: false, // New flag to lock the cursor position during playback\n  // Utility functions for time conversion\n  timelineHourToTimestamp,\n  timestampToTimelineHour,\n  listeners: new Set(),\n\n  // Last time state was updated\n  lastUpdateTime: 0,\n\n  // Pending state updates\n  pendingUpdates: {},\n\n  // Update state and notify listeners\n  setState(newState) {\n    const now = Date.now();\n\n    console.log('timelineState: setState called with', newState);\n    console.log('timelineState: current state before update', {\n      currentTime: this.currentTime,\n      currentSegmentIndex: this.currentSegmentIndex,\n      segmentsLength: this.timelineSegments.length\n    });\n\n    // For time-sensitive updates (like currentTime), we want to batch them\n    // to prevent too many updates in a short period\n    if (newState.currentTime !== undefined &&\n        !newState.currentSegmentIndex &&\n        !newState.isPlaying &&\n        now - this.lastUpdateTime < 250) {\n      // Skip frequent time updates that don't change playback state\n      console.log('timelineState: Skipping frequent time update');\n      return;\n    }\n\n    // Apply the new state\n    Object.assign(this, newState);\n\n    // Reset forceReload flag immediately\n    if (newState.forceReload) {\n      this.forceReload = false;\n    }\n\n    this.lastUpdateTime = now;\n\n    console.log('timelineState: state after update', {\n      currentTime: this.currentTime,\n      currentSegmentIndex: this.currentSegmentIndex,\n      segmentsLength: this.timelineSegments.length\n    });\n\n    this.notifyListeners();\n  },\n\n  // Subscribe to state changes\n  subscribe(listener) {\n    this.listeners.add(listener);\n    return () => this.listeners.delete(listener);\n  },\n\n  // Notify all listeners of state change\n  notifyListeners() {\n    this.listeners.forEach(listener => listener(this));\n  },\n\n  // Flush any pending updates\n  flushPendingUpdates() {\n    if (Object.keys(this.pendingUpdates).length > 0) {\n      Object.assign(this, this.pendingUpdates);\n      this.pendingUpdates = {};\n      this.lastUpdateTime = Date.now();\n      this.notifyListeners();\n    }\n  }\n};\n\n/**\n * Format date for input element\n */\nfunction formatDateForInput(date) {\n  const year = date.getFullYear();\n  const month = String(date.getMonth() + 1).padStart(2, '0');\n  const day = String(date.getDate()).padStart(2, '0');\n  return `${year}-${month}-${day}`;\n}\n\n/**\n * Parse URL parameters\n */\nfunction parseUrlParams() {\n  const params = new URLSearchParams(window.location.search);\n  return {\n    stream: params.get('stream') || '',\n    date: params.get('date') || formatDateForInput(new Date())\n  };\n}\n\n/**\n * Update URL parameters\n */\nfunction updateUrlParams(stream, date) {\n  if (!stream) return;\n  const url = new URL(window.location.href);\n  url.searchParams.set('stream', stream);\n  url.searchParams.set('date', date);\n  window.history.replaceState({}, '', url);\n}\n\n/**\n * TimelinePage component\n */\nexport function TimelinePage() {\n  // Get initial values from URL parameters\n  const urlParams = parseUrlParams();\n\n  // State\n  const [isLoading, setIsLoading] = useState(false);\n  const [streamsList, setStreamsList] = useState([]);\n  const [selectedStream, setSelectedStream] = useState(urlParams.stream);\n  const [selectedDate, setSelectedDate] = useState(urlParams.date);\n  const [segments, setSegments] = useState([]);\n\n  // Refs\n  const timelineContainerRef = useRef(null);\n  const initialLoadRef = useRef(false);\n  const flushIntervalRef = useRef(null);\n\n  // Set up periodic flush of pending updates\n  useEffect(() => {\n    // Set up interval to flush pending updates every 200ms\n    flushIntervalRef.current = setInterval(() => {\n      timelineState.flushPendingUpdates();\n    }, 200);\n\n    // Clean up interval on unmount\n    return () => {\n      if (flushIntervalRef.current) {\n        clearInterval(flushIntervalRef.current);\n      }\n    };\n  }, []);\n\n  // Load streams using preact-query\n  const {\n    data: streamsData,\n    isLoading: isLoadingStreams,\n    error: streamsError\n  } = useQuery('streams', '/api/streams', {\n    timeout: 15000, // 15 second timeout\n    retries: 2,     // Retry twice\n    retryDelay: 1000 // 1 second between retries\n  });\n\n  // Handle initial data load when streams are available\n  useEffect(() => {\n    if (streamsData && Array.isArray(streamsData) && streamsData.length > 0 && !initialLoadRef.current) {\n      console.log('TimelinePage: Streams loaded, initializing data');\n      initialLoadRef.current = true;\n\n      // Update streamsList state\n      setStreamsList(streamsData);\n\n      // Update global state for child components\n      timelineState.setState({ streams: streamsData });\n\n      // Check if the selected stream from URL exists\n      const streamExists = streamsData.some(s => s.name === selectedStream);\n\n      if (streamExists && selectedStream) {\n        console.log(`TimelinePage: Using stream from URL: ${selectedStream}`);\n      } else if (streamsData.length > 0) {\n        // Use first stream if URL stream doesn't exist\n        const firstStream = streamsData[0].name;\n        console.log(`TimelinePage: Using first stream: ${firstStream}`);\n        setSelectedStream(firstStream);\n      }\n    }\n  }, [streamsData]);\n\n  // Handle streams error\n  useEffect(() => {\n    if (streamsError) {\n      console.error('TimelinePage: Error loading streams:', streamsError);\n      showStatusMessage('Error loading streams: ' + streamsError.message, 'error');\n    }\n  }, [streamsError]);\n\n  // Calculate time range for timeline data\n  const getTimeRange = (date) => {\n    const startDate = new Date(date);\n    startDate.setHours(0, 0, 0, 0);\n\n    const endDate = new Date(date);\n    endDate.setHours(23, 59, 59, 999);\n\n    // Format dates for API in ISO format\n    const startTime = startDate.toISOString();\n    const endTime = endDate.toISOString();\n\n    console.log('TimelinePage: Generated time range:', {\n      date,\n      startDate: startDate.toString(),\n      endDate: endDate.toString(),\n      startTime,\n      endTime\n    });\n\n    return {\n      startTime,\n      endTime\n    };\n  };\n\n  // Update URL and global state when stream or date changes\n  useEffect(() => {\n    if (selectedStream) {\n      // Update URL\n      updateUrlParams(selectedStream, selectedDate);\n\n      // Update global state\n      timelineState.setState({\n        selectedStream,\n        selectedDate\n      });\n    }\n  }, [selectedStream, selectedDate]);\n\n  // Get time range for current date\n  const timeRange = getTimeRange(selectedDate);\n  const startTime = timeRange.startTime;\n  const endTime = timeRange.endTime;\n\n  // Construct the URL for the API call\n  const timelineUrl = selectedStream ?\n    `/api/timeline/segments?stream=${encodeURIComponent(selectedStream)}&start=${encodeURIComponent(startTime)}&end=${encodeURIComponent(endTime)}` :\n    null;\n\n  // Debug the URL being used\n  console.log('TimelinePage: Timeline URL:', timelineUrl);\n\n  // Fetch timeline segments using preact-query\n  const {\n    data: timelineData,\n    isLoading: isLoadingTimeline,\n    error: timelineError,\n    refetch: refetchTimeline\n  } = useQuery(\n    ['timeline-segments', selectedStream, selectedDate],\n    timelineUrl,\n    {\n      timeout: 30000, // 30 second timeout\n      retries: 2,     // Retry twice\n      retryDelay: 1000 // 1 second between retries\n    },\n    {\n      enabled: !!selectedStream, // Only run query if we have a selected stream\n      onSuccess: (data) => {\n        console.log('TimelinePage: Timeline data received:', data);\n        const timelineSegments = data.segments || [];\n        console.log(`TimelinePage: Received ${timelineSegments.length} segments`);\n\n        if (timelineSegments.length === 0) {\n          console.log('TimelinePage: No segments found');\n          setSegments([]);\n\n          // Update global state\n          timelineState.setState({\n            timelineSegments: [],\n            currentSegmentIndex: -1,\n            currentTime: null,\n            isPlaying: false\n          });\n\n          showStatusMessage('No recordings found for the selected date', 'warning');\n          return;\n        }\n\n        // IMPORTANT: Make a deep copy of the segments to avoid reference issues\n        const segmentsCopy = JSON.parse(JSON.stringify(timelineSegments));\n\n        // Log the first few segments for debugging\n        segmentsCopy.slice(0, 3).forEach((segment, i) => {\n          const startTime = new Date(segment.start_timestamp * 1000);\n          const endTime = new Date(segment.end_timestamp * 1000);\n          console.log(`TimelinePage: Segment ${i} - Start: ${startTime.toLocaleTimeString()}, End: ${endTime.toLocaleTimeString()}`);\n        });\n\n        console.log('TimelinePage: Setting segments');\n        setSegments(segmentsCopy);\n\n        // Force a synchronous DOM update\n        document.body.offsetHeight;\n\n        // Directly update the global state with the segments\n        const firstSegmentStartTime = segmentsCopy[0].start_timestamp;\n\n        console.log('TimelinePage: Setting initial segment and time', {\n          firstSegmentId: segmentsCopy[0].id,\n          startTime: new Date(firstSegmentStartTime * 1000).toLocaleTimeString()\n        });\n\n        // DIRECT ASSIGNMENT to ensure state is properly set\n        console.log('TimelinePage: Directly setting timelineState properties');\n        timelineState.timelineSegments = segmentsCopy;\n        timelineState.currentSegmentIndex = 0;\n        timelineState.currentTime = firstSegmentStartTime;\n        timelineState.prevCurrentTime = firstSegmentStartTime;\n        timelineState.isPlaying = false;\n        timelineState.forceReload = true;\n        timelineState.zoomLevel = 1;\n        timelineState.selectedDate = selectedDate; // Make sure the date is set\n\n        // Now call setState to notify listeners\n        timelineState.setState({\n          // Empty object just to trigger notification\n        });\n\n        console.log('TimelinePage: Updated timelineState with segments');\n\n        // Wait a moment to ensure state is updated, then log the current state\n        setTimeout(() => {\n          console.log('TimelinePage: State after update (delayed check):', {\n            segmentsLength: timelineState.timelineSegments.length,\n            currentSegmentIndex: timelineState.currentSegmentIndex,\n            currentTime: timelineState.currentTime\n          });\n\n          // Force a state update if the state wasn't properly updated\n          if (!timelineState.currentTime || timelineState.currentSegmentIndex === -1) {\n            console.log('TimelinePage: State not properly updated, forcing update');\n            timelineState.setState({\n              currentSegmentIndex: 0,\n              currentTime: firstSegmentStartTime,\n              prevCurrentTime: firstSegmentStartTime\n            });\n          }\n        }, 100);\n\n        // Preload the first segment's video\n        const videoPlayer = document.querySelector('#video-player video');\n        if (videoPlayer) {\n          videoPlayer.src = `/api/recordings/play/${segmentsCopy[0].id}?t=${Date.now()}`;\n          videoPlayer.load();\n        }\n\n        showStatusMessage(`Loaded ${segmentsCopy.length} recording segments`, 'success');\n      },\n      onError: (error) => {\n        console.error('TimelinePage: Error loading timeline data:', error);\n        console.error('TimelinePage: Error details:', {\n          message: error.message,\n          status: error.status,\n          statusText: error.statusText,\n          response: error.response\n        });\n        showStatusMessage('Error loading timeline data: ' + error.message, 'error');\n        setSegments([]);\n      }\n    }\n  );\n\n  // Handle stream selection change\n  const handleStreamChange = (e) => {\n    const newStream = e.target.value;\n    console.log(`TimelinePage: Stream changed to ${newStream}`);\n    setSelectedStream(newStream);\n  };\n\n  // Handle date selection change\n  const handleDateChange = (e) => {\n    const newDate = e.target.value;\n    console.log(`TimelinePage: Date changed to ${newDate}`);\n    setSelectedDate(newDate);\n  };\n\n  // Render content based on state\n  const renderContent = () => {\n    if (isLoadingTimeline) {\n      return <LoadingIndicator message=\"Loading timeline data...\" />;\n    }\n\n    if (segments.length === 0) {\n      return (\n        <div className=\"flex flex-col items-center justify-center py-12 text-center\">\n          <svg className=\"w-16 h-16 text-gray-400 dark:text-gray-600 mb-4\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\" xmlns=\"http://www.w3.org/2000/svg\">\n            <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth=\"2\" d=\"M9.172 16.172a4 4 0 015.656 0M9 10h.01M15 10h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z\"></path>\n          </svg>\n          <p className=\"text-gray-600 dark:text-gray-400 text-lg\">No recordings found for the selected date and stream</p>\n        </div>\n      );\n    }\n\n    return (\n      <>\n        {/* Video player */}\n        <TimelinePlayer />\n\n        {/* Playback controls */}\n        <TimelineControls />\n\n        {/* Timeline */}\n        <div\n          id=\"timeline-container\"\n          className=\"relative w-full h-24 bg-gray-200 dark:bg-gray-700 border border-gray-300 dark:border-gray-600 rounded-lg mb-6 overflow-hidden\"\n          ref={timelineContainerRef}\n        >\n          <TimelineRuler />\n          <TimelineSegments segments={segments} />\n          <TimelineCursor />\n\n          {/* Instructions for cursor */}\n          <div className=\"absolute bottom-1 right-2 text-xs text-gray-500 dark:text-gray-400 bg-white dark:bg-gray-800 bg-opacity-75 dark:bg-opacity-75 px-2 py-1 rounded\">\n            Drag the orange dial to navigate\n          </div>\n        </div>\n      </>\n    );\n  };\n\n  return (\n    <div className=\"timeline-page\">\n      <div className=\"flex items-center mb-4\">\n        <h1 className=\"text-2xl font-bold\">Timeline Playback</h1>\n        <div className=\"ml-4 flex\">\n          <a href=\"recordings.html\" className=\"px-3 py-1 bg-gray-300 text-gray-700 dark:bg-gray-700 dark:text-gray-300 hover:bg-gray-400 dark:hover:bg-gray-600 rounded-l-md\">Table View</a>\n          <a href=\"timeline.html\" className=\"px-3 py-1 bg-blue-500 text-white rounded-r-md\">Timeline View</a>\n        </div>\n      </div>\n\n      {/* Stream selector and date picker */}\n      <div className=\"flex flex-wrap gap-4 mb-2\">\n        <div className=\"stream-selector flex-grow\">\n          <div className=\"flex justify-between items-center mb-2\">\n            <label htmlFor=\"stream-selector\">Stream</label>\n            <button\n              className=\"text-xs bg-gray-200 hover:bg-gray-300 dark:bg-gray-700 dark:hover:bg-gray-600 px-2 py-1 rounded\"\n              onClick={() => refetchTimeline()}\n            >\n              Reload Data\n            </button>\n          </div>\n          <select\n            id=\"stream-selector\"\n            className=\"w-full p-2 border rounded dark:bg-gray-700 dark:border-gray-600 dark:text-white\"\n            value={selectedStream || ''}\n            onChange={handleStreamChange}\n          >\n            <option value=\"\" disabled>Select a stream ({streamsList.length} available)</option>\n            {streamsList.map(stream => (\n              <option key={stream.name} value={stream.name}>{stream.name}</option>\n            ))}\n          </select>\n        </div>\n\n        <div className=\"date-selector flex-grow\">\n          <label htmlFor=\"timeline-date\" className=\"block mb-2\">Date</label>\n          <input\n            type=\"date\"\n            id=\"timeline-date\"\n            className=\"w-full p-2 border rounded dark:bg-gray-700 dark:border-gray-600 dark:text-white\"\n            value={selectedDate}\n            onChange={handleDateChange}\n          />\n        </div>\n      </div>\n\n      {/* Auto-load message */}\n      <div className=\"mb-4 text-sm text-gray-500 dark:text-gray-400 italic\">\n        {isLoadingTimeline ? 'Loading...' : 'Recordings auto-load when stream or date changes'}\n      </div>\n\n      {/* Current time display */}\n      <div className=\"flex justify-between items-center mb-2\">\n        <div id=\"time-display\" className=\"timeline-time-display bg-gray-200 dark:bg-gray-700 px-3 py-1 rounded font-mono text-base\">00:00:00</div>\n      </div>\n\n      {/* Debug info */}\n      <div className=\"mb-2 text-xs text-gray-500\">\n        Debug - isLoading: {isLoadingTimeline ? 'true' : 'false'},\n        Streams: {streamsList.length},\n        Segments: {segments.length}\n      </div>\n\n      {/* Content */}\n      {renderContent()}\n\n      {/* Instructions */}\n      <div className=\"mt-6 p-4 bg-gray-200 dark:bg-gray-800 rounded\">\n        <h3 className=\"text-lg font-semibold mb-2\">How to use the timeline:</h3>\n        <ul className=\"list-disc pl-5\">\n          <li>Select a stream and date to load recordings</li>\n          <li>Click on the timeline to position the cursor at a specific time</li>\n          <li>Drag the orange cursor to navigate precisely</li>\n          <li>Click on a segment (blue bar) to play that recording</li>\n          <li>Use the play button to start playback from the current cursor position</li>\n          <li>Use the zoom buttons to adjust the timeline scale</li>\n        </ul>\n      </div>\n    </div>\n  );\n}\n\n// Export the timeline state for use in other components\nexport { timelineState };\n","/**\n * LightNVR Web Interface Users Page\n * Entry point for the users page\n */\n\nimport { render } from 'preact';\nimport { TimelinePage } from '../components/preact/timeline/TimelinePage.jsx';\nimport { QueryClientProvider, queryClient } from '../query-client.js';\nimport {Header} from \"../components/preact/Header.jsx\";\nimport {Footer} from \"../components/preact/Footer.jsx\";\nimport { ToastContainer } from \"../components/preact/ToastContainer.jsx\";\n\n// Render the UsersView component when the DOM is loaded\ndocument.addEventListener('DOMContentLoaded', () => {\n    // Get the container element\n    const container = document.getElementById('main-content');\n\n    if (container) {\n        render(\n            <QueryClientProvider client={queryClient}>\n                <Header />\n                <ToastContainer />\n                <TimelinePage />\n                <Footer />\n            </QueryClientProvider>,\n            container\n        );\n    }\n});\n"],"names":["TimelineControls","isPlaying","setIsPlaying","useState","zoomLevel","setZoomLevel","useEffect","unsubscribe","timelineState","state","togglePlayback","pausePlayback","resumePlayback","videoPlayer","showStatusMessage","segmentToPlay","segmentIndex","relativeTime","i","segment","closestIndex","minDistance","midpoint","distance","videoElement","handleMetadataLoaded","timeToSet","distanceToStart","distanceToEnd","validTime","checkPlayback","attempt","e","segmentDuration","monitorInterval","error","zoomIn","newZoomLevel","jsxs","jsx","Fragment","TimelineRuler","startHour","setStartHour","endHour","setEndHour","hoursPerView","centerHour","currentDate","earliestHour","latestHour","startTime","endTime","newStartHour","newEndHour","markers","hour","position","halfHourPosition","quarterHourPosition1","quarterHourPosition3","TimelineSegments","propSegments","segments","setSegments","currentSegmentIndex","setCurrentSegmentIndex","containerRef","useRef","isDragging","lastSegmentsUpdateRef","lastSegmentsRef","container","handleMouseDown","handleTimelineClick","handleMouseMove","handleMouseUp","event","rect","clickX","containerWidth","clickPercent","clickHour","clickDate","clickTimestamp","foundSegment","startTimestamp","endTimestamp","playSegment","index","absoluteTime","seekTime","_a","__template","visibleSegments","hourMap","visibleCount","skippedCount","startHourFloat","endHourFloat","startFloorHour","endCeilHour","h","mergedSegments","currentMergedSegment","a","b","segmentStart","mergedEnd","mergedIndex","segStartTimestamp","segEndTimestamp","visibleStartHour","visibleEndHour","startPercent","widthPercent","duration","durationStr","startTimeStr","endTimeStr","width","TimelineCursor","setPosition","visible","setVisible","currentTime","setCurrentTime","setIsDragging","cursorRef","dragStartXRef","debouncedUpdateCursorPosition","func","delay","timeoutId","args","time","startHr","endHr","updateCursorPosition","updateTimeDisplay","cursor","positionPercent","hourRange","timestamp","seg","adjustedTime","closestSegment","date","timeDisplay","hours","minutes","seconds","initCursor","segmentStartTime","SpeedControls","currentSpeed","setCurrentSpeed","speeds","setPlaybackSpeed","speed","TimelinePlayer","playbackSpeed","videoRef","lastTimeUpdateRef","lastSegmentIdRef","handleVideoPlayback","video","segmentChanged","needsReload","timeChanged","loadSegment","autoplay","recordingUrl","onLoadedMetadata","validSeekTime","handleEnded","nextIndex","wasUserControllingCursor","handleTimeUpdate","timelineHourToTimestamp","selectedDate","milliseconds","timestampToTimelineHour","newState","now","listener","formatDateForInput","year","month","day","parseUrlParams","params","updateUrlParams","stream","url","TimelinePage","urlParams","isLoading","setIsLoading","streamsList","setStreamsList","selectedStream","setSelectedStream","setSelectedDate","timelineContainerRef","initialLoadRef","flushIntervalRef","streamsData","isLoadingStreams","streamsError","useQuery","s","firstStream","getTimeRange","startDate","endDate","timeRange","timelineUrl","timelineData","isLoadingTimeline","timelineError","refetchTimeline","data","timelineSegments","segmentsCopy","firstSegmentStartTime","handleStreamChange","newStream","handleDateChange","newDate","renderContent","LoadingIndicator","render","QueryClientProvider","queryClient","Header","ToastContainer","Footer"],"mappings":"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"}