{"version":3,"file":"LiveView-legacy-BJ2PEA2J.js","sources":["../../js/components/preact/VideoPlayer.js","../../js/components/preact/SnapshotManager.js","../../js/components/preact/StreamGrid.js","../../js/components/preact/LiveView.js"],"sourcesContent":["/**\n * Video player functionality for LiveView\n */\n\nimport { showStatusMessage } from './UI.js';\nimport { startDetectionPolling, cleanupDetectionPolling } from './DetectionOverlay.js';\n\n/**\n * Initialize video player for a stream\n * @param {Object} stream - Stream object\n * @param {Object} videoPlayers - Reference to store video player instances\n * @param {Object} detectionIntervals - Reference to store detection intervals\n */\nexport function initializeVideoPlayer(stream, videoPlayers, detectionIntervals) {\n  const videoElementId = `video-${stream.name.replace(/\\s+/g, '-')}`;\n  const videoElement = document.getElementById(videoElementId);\n  const videoCell = videoElement ? videoElement.closest('.video-cell') : null;\n  \n  if (!videoElement || !videoCell) return;\n  \n  // Create canvas overlay for detection bounding boxes\n  const canvasId = `canvas-${stream.name.replace(/\\s+/g, '-')}`;\n  let canvasOverlay = document.getElementById(canvasId);\n  \n  if (!canvasOverlay) {\n    canvasOverlay = document.createElement('canvas');\n    canvasOverlay.id = canvasId;\n    canvasOverlay.className = 'detection-overlay';\n    canvasOverlay.style.position = 'absolute';\n    canvasOverlay.style.top = '0';\n    canvasOverlay.style.left = '0';\n    canvasOverlay.style.width = '100%';\n    canvasOverlay.style.height = '100%';\n    canvasOverlay.style.pointerEvents = 'none'; // Allow clicks to pass through\n    videoCell.appendChild(canvasOverlay);\n  }\n  \n  // Start detection polling if detection is enabled for this stream\n  console.log(`Stream ${stream.name} detection settings:`, {\n    detection_based_recording: stream.detection_based_recording,\n    detection_model: stream.detection_model,\n    detection_threshold: stream.detection_threshold\n  });\n  \n  if (stream.detection_based_recording && stream.detection_model) {\n    console.log(`Starting detection polling for stream ${stream.name}`);\n    startDetectionPolling(stream.name, canvasOverlay, videoElement, detectionIntervals);\n  } else {\n    console.log(`Detection not enabled for stream ${stream.name}`);\n  }\n  \n  // Show loading state\n  const loadingIndicator = videoCell.querySelector('.loading-indicator');\n  if (loadingIndicator) {\n    loadingIndicator.style.display = 'flex';\n  }\n  \n  // Build the HLS stream URL with cache-busting timestamp to prevent stale data\n  const timestamp = Date.now();\n  const hlsStreamUrl = `/hls/${encodeURIComponent(stream.name)}/index.m3u8?_t=${timestamp}`;\n  \n  // Get auth from localStorage\n  const auth = localStorage.getItem('auth');\n  \n  // Ensure auth headers are set for HLS requests\n  console.log(`Initializing video player for stream ${stream.name}`);\n  \n  // Check if HLS is supported natively\n  if (videoElement.canPlayType('application/vnd.apple.mpegurl')) {\n    // Native HLS support (Safari)\n    console.log(`Using native HLS support for stream ${stream.name}`);\n    \n    // Set source directly\n    videoElement.src = hlsStreamUrl;\n    \n    // Hide loading indicator when metadata is loaded\n    videoElement.addEventListener('loadedmetadata', function() {\n      console.log(`Metadata loaded for stream ${stream.name}`);\n      if (loadingIndicator) {\n        loadingIndicator.style.display = 'none';\n      }\n    });\n    \n    // Handle errors\n    videoElement.addEventListener('error', (e) => {\n      console.error(`Video error for stream ${stream.name}:`, videoElement.error);\n      handleVideoError(stream.name, videoElement.error ? videoElement.error.message : 'Unknown error');\n    });\n    \n    // Try to play automatically\n    videoElement.play().catch(error => {\n      console.warn('Auto-play prevented:', error);\n      // Add play button overlay for user interaction\n      addPlayButtonOverlay(videoCell, videoElement);\n    });\n  }\n    // Use HLS.js for browsers that don't support HLS natively\n    else if (window.Hls && window.Hls.isSupported()) {\n        // Get auth from localStorage\n        const auth = localStorage.getItem('auth');\n        \n        // Check if this is a mobile device\n        const isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);\n        \n        // Configure HLS.js with settings optimized for the device type\n        const hls = new window.Hls({\n            // Increase buffer settings for mobile devices to improve stability\n            maxBufferLength: isMobile ? 30 : 20,\n            maxMaxBufferLength: isMobile ? 60 : 30,\n            // Increase sync settings for mobile to handle network fluctuations\n            liveSyncDurationCount: isMobile ? 4 : 3,\n            liveMaxLatencyDurationCount: isMobile ? 10 : 6,\n            liveDurationInfinity: false,\n            // Disable low latency mode as it can cause issues on mobile devices\n            lowLatencyMode: false,\n            // Enable worker for better performance\n            enableWorker: true,\n            // Increase timeouts for mobile devices to handle slower networks\n            fragLoadingTimeOut: isMobile ? 60000 : 30000,\n            manifestLoadingTimeOut: isMobile ? 60000 : 30000,\n            levelLoadingTimeOut: isMobile ? 60000 : 30000,\n            // Increase back buffer length for mobile\n            backBufferLength: isMobile ? 60 : 30,\n            // Start with lower quality on mobile for faster initial load\n            startLevel: isMobile ? 0 : -1,\n            // More conservative ABR settings for mobile\n            abrEwmaDefaultEstimate: isMobile ? 1000000 : 500000,\n            abrBandWidthFactor: isMobile ? 0.5 : 0.7,\n            abrBandWidthUpFactor: isMobile ? 0.3 : 0.5,\n            // Add custom headers to all HLS requests\n            xhrSetup: function(xhr, url) {\n                // Add Authorization header if we have auth in localStorage\n                if (auth) {\n                    xhr.setRequestHeader('Authorization', 'Basic ' + auth);\n                }\n                // Always include credentials (cookies)\n                xhr.withCredentials = true;\n            }\n        });\n    \n    hls.loadSource(hlsStreamUrl);\n    hls.attachMedia(videoElement);\n    \n            hls.on(window.Hls.Events.MANIFEST_PARSED, () => {\n                console.log(`Manifest parsed for stream ${stream.name}`);\n                \n                // On mobile, we need to be more careful with autoplay\n                const isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);\n                \n                if (isMobile) {\n                    console.log(`Mobile device detected for stream ${stream.name}, using muted autoplay`);\n                    // For mobile, always mute the video first to allow autoplay\n                    videoElement.muted = true;\n                    \n                    // Hide loading indicator after a short delay to ensure UI is ready\n                    setTimeout(() => {\n                        if (loadingIndicator) {\n                            loadingIndicator.style.display = 'none';\n                        }\n                        \n                        // Try to play with muted audio first (more likely to succeed on mobile)\n                        videoElement.play().then(() => {\n                            console.log(`Autoplay succeeded for stream ${stream.name} on mobile`);\n                        }).catch(error => {\n                            console.warn(`Autoplay failed for stream ${stream.name} on mobile:`, error);\n                            // Show play button if autoplay fails even with muted audio\n                            addPlayButtonOverlay(videoCell, videoElement);\n                        });\n                    }, 500);\n                } else {\n                    // For desktop, proceed as before\n                    if (loadingIndicator) {\n                        loadingIndicator.style.display = 'none';\n                    }\n                    \n                    // Try to play automatically\n                    videoElement.play().catch(error => {\n                        console.warn('Auto-play prevented:', error);\n                        // Add play button overlay for user interaction\n                        addPlayButtonOverlay(videoCell, videoElement);\n                    });\n                }\n            });\n    \n    hls.on(window.Hls.Events.ERROR, (event, data) => {\n      console.warn('HLS error:', data);\n      \n      // Handle fatal errors\n      if (data.fatal) {\n        console.error('Fatal HLS error:', data);\n        hls.destroy();\n        \n        // Check if the stream was recently enabled\n        const videoCell = videoElement.closest('.video-cell');\n        const loadingIndicator = videoCell.querySelector('.loading-indicator');\n        \n        // If the stream was recently enabled (indicated by the loading message),\n        // automatically retry after a short delay\n        if (loadingIndicator && \n            loadingIndicator.querySelector('span').textContent === 'Starting stream...') {\n          \n          console.log(`Stream ${stream.name} failed to load after enabling, retrying in 2 seconds...`);\n          \n          // Show retry message\n          loadingIndicator.querySelector('span').textContent = 'Retrying connection...';\n          \n          // Retry after a delay\n          setTimeout(() => {\n            console.log(`Retrying stream ${stream.name} after failure`);\n            // Fetch updated stream info and reinitialize\n            fetch(`/api/streams/${encodeURIComponent(stream.name)}`)\n              .then(response => response.json())\n              .then(updatedStream => {\n                // Cleanup existing player\n                cleanupVideoPlayer(stream.name, videoPlayers, detectionIntervals);\n                // Reinitialize with updated stream info\n                initializeVideoPlayer(updatedStream, videoPlayers, detectionIntervals);\n              })\n              .catch(error => {\n                console.error(`Error fetching stream info for retry: ${error}`);\n                handleVideoError(stream.name, 'Failed to reconnect after enabling');\n              });\n          }, 2000);\n        } else {\n          // Use a standard retry strategy for all devices\n          console.log(`Implementing standard retry for stream ${stream.name}`);\n          \n          // Show loading indicator with retry message\n          if (loadingIndicator) {\n            loadingIndicator.style.display = 'flex';\n            const messageSpan = loadingIndicator.querySelector('span');\n            if (messageSpan) {\n              messageSpan.textContent = 'Reconnecting to stream...';\n            }\n          }\n          \n          // Try to recover with a new HLS instance after a delay\n          setTimeout(() => {\n            try {\n              // Create a new timestamp to avoid caching issues\n              const newTimestamp = Date.now();\n              const newUrl = `/hls/${encodeURIComponent(stream.name)}/index.m3u8?_t=${newTimestamp}`;\n              \n              // Create a new HLS instance with the same settings as the main instance\n              const newHls = new window.Hls({\n                // Increase buffer settings for mobile devices to improve stability\n                maxBufferLength: isMobile ? 30 : 20,\n                maxMaxBufferLength: isMobile ? 60 : 30,\n                // Increase sync settings for mobile to handle network fluctuations\n                liveSyncDurationCount: isMobile ? 4 : 3,\n                liveMaxLatencyDurationCount: isMobile ? 10 : 6,\n                liveDurationInfinity: false,\n                // Disable low latency mode as it can cause issues on mobile devices\n                lowLatencyMode: false,\n                // Enable worker for better performance\n                enableWorker: true,\n                // Increase timeouts for mobile devices to handle slower networks\n                fragLoadingTimeOut: isMobile ? 60000 : 30000,\n                manifestLoadingTimeOut: isMobile ? 60000 : 30000,\n                levelLoadingTimeOut: isMobile ? 60000 : 30000,\n                // Increase back buffer length for mobile\n                backBufferLength: isMobile ? 60 : 30,\n                // Start with lower quality on mobile for faster initial load\n                startLevel: isMobile ? 0 : -1,\n                // More conservative ABR settings for mobile\n                abrEwmaDefaultEstimate: isMobile ? 1000000 : 500000,\n                abrBandWidthFactor: isMobile ? 0.5 : 0.7,\n                abrBandWidthUpFactor: isMobile ? 0.3 : 0.5,\n                // Add custom headers to all HLS requests\n                xhrSetup: function(xhr, url) {\n                  // Add Authorization header if we have auth in localStorage\n                  if (auth) {\n                    xhr.setRequestHeader('Authorization', 'Basic ' + auth);\n                  }\n                  // Always include credentials (cookies)\n                  xhr.withCredentials = true;\n                }\n              });\n              \n              // Load the new source\n              newHls.loadSource(newUrl);\n              newHls.attachMedia(videoElement);\n              \n              // Store the new HLS instance\n              if (videoCell) {\n                if (videoCell.hlsPlayer) {\n                  videoCell.hlsPlayer.destroy();\n                }\n                videoCell.hlsPlayer = newHls;\n              }\n              \n              // Store in ref for cleanup\n              videoPlayers[stream.name] = { \n                hls: newHls, \n                refreshTimer: videoPlayers[stream.name] ? videoPlayers[stream.name].refreshTimer : null \n              };\n              \n              // Hide loading indicator when media is attached\n              newHls.on(window.Hls.Events.MEDIA_ATTACHED, () => {\n                console.log(`New HLS instance attached for stream ${stream.name}`);\n                if (loadingIndicator) {\n                  loadingIndicator.style.display = 'none';\n                }\n                \n                // Show play button for all devices to ensure consistent behavior\n                addPlayButtonOverlay(videoCell, videoElement);\n              });\n              \n              // Handle errors in the new instance\n              newHls.on(window.Hls.Events.ERROR, (event, newData) => {\n                if (newData.fatal) {\n                  console.error('Fatal error in recovery HLS instance:', newData);\n                  newHls.destroy();\n                  handleVideoError(stream.name, 'Failed to reconnect after multiple attempts');\n                }\n              });\n            } catch (error) {\n              console.error('Error during HLS recovery:', error);\n              handleVideoError(stream.name, 'Failed to reconnect: ' + error.message);\n            }\n          }, 3000);\n        }\n      } else if (data.type === window.Hls.ErrorTypes.NETWORK_ERROR) {\n        // For non-fatal network errors, try to recover\n        console.warn('Network error, attempting to recover:', data);\n        \n        // Try to recover by seeking slightly\n        if (videoElement.currentTime > 0) {\n          try {\n            // Seek to live edge\n            hls.recoverMediaError();\n            videoElement.currentTime = videoElement.duration - 1;\n          } catch (e) {\n            console.error('Error during recovery seek:', e);\n          }\n        }\n        \n        // For fragment load errors, try to switch to a lower quality\n        if (data.details === window.Hls.ErrorDetails.FRAG_LOAD_ERROR ||\n            data.details === window.Hls.ErrorDetails.FRAG_LOAD_TIMEOUT) {\n          \n          try {\n            // Get current level\n            const currentLevel = hls.currentLevel;\n            \n            // If not already at lowest level, switch to a lower one\n            if (currentLevel > 0) {\n              console.log(`Switching from level ${currentLevel} to level 0 due to fragment error`);\n              hls.currentLevel = 0;\n            }\n          } catch (e) {\n            console.error('Error during level switching:', e);\n          }\n        }\n      } else if (data.type === window.Hls.ErrorTypes.MEDIA_ERROR) {\n        // For media errors, try to recover\n        console.warn('Media error, attempting to recover:', data);\n        try {\n          hls.recoverMediaError();\n        } catch (e) {\n          console.error('Error during media error recovery:', e);\n        }\n      }\n    });\n    \n    // Set up a universal refresh interval\n    const refreshInterval = 30000; // 30 seconds for all devices\n    const refreshTimer = setInterval(() => {\n      if (videoCell && videoCell.hlsPlayer) {\n        console.log(`Refreshing HLS stream for ${stream.name}`);\n        const newTimestamp = Date.now();\n        const newUrl = `/hls/${encodeURIComponent(stream.name)}/index.m3u8?_t=${newTimestamp}`;\n        \n        // Check if the player is in a good state before refreshing\n        if (!videoCell.hlsPlayer.autoLevelCapping) {\n          videoCell.hlsPlayer.loadSource(newUrl);\n        } else {\n          console.log(`Skipping refresh for ${stream.name} as it appears to be in recovery mode`);\n        }\n      } else {\n        // Clear interval if video cell or player no longer exists\n        clearInterval(refreshTimer);\n      }\n    }, refreshInterval);\n    \n    // Store hls instance and timer for cleanup\n    videoCell.hlsPlayer = hls;\n    videoCell.refreshTimer = refreshTimer;\n    \n    // Store in ref for cleanup\n    videoPlayers[stream.name] = { hls, refreshTimer };\n  }\n  // Fallback for unsupported browsers\n  else {\n    handleVideoError(stream.name, 'HLS not supported by your browser');\n  }\n}\n\n/**\n * Add play button overlay\n * @param {HTMLElement} videoCell - Video cell element\n * @param {HTMLVideoElement} videoElement - Video element\n */\nexport function addPlayButtonOverlay(videoCell, videoElement) {\n  // Check if play overlay already exists\n  if (videoCell.querySelector('.play-overlay')) {\n    return;\n  }\n  \n  const playOverlay = document.createElement('div');\n  playOverlay.className = 'play-overlay';\n  \n  const playButton = document.createElement('div');\n  playButton.className = 'play-button';\n  playButton.innerHTML = `\n    <svg class=\"w-8 h-8 text-white\" fill=\"currentColor\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\">\n      <path fill-rule=\"evenodd\" d=\"M10 18a8 8 0 100-16 8 8 0 000 16zM9.555 7.168A1 1 0 008 8v4a1 1 0 001.555.832l3-2a1 1 0 000-1.664l-3-2z\" clip-rule=\"evenodd\"></path>\n    </svg>\n  `;\n  \n  // Add tap/click message for mobile\n  if (/iPhone|iPad|iPod|Android/i.test(navigator.userAgent)) {\n    const tapMessage = document.createElement('div');\n    tapMessage.className = 'tap-message';\n    tapMessage.textContent = 'Tap to play';\n    tapMessage.style.color = 'white';\n    tapMessage.style.marginTop = '10px';\n    tapMessage.style.fontSize = '14px';\n    playButton.appendChild(tapMessage);\n  }\n  \n  playOverlay.appendChild(playButton);\n  videoCell.appendChild(playOverlay);\n  \n  // Use both click and touchend events for better mobile response\n  const playHandler = function() {\n    // Disable the overlay immediately to prevent multiple taps\n    playOverlay.style.pointerEvents = 'none';\n    \n    // Show loading indicator\n    const loadingIndicator = videoCell.querySelector('.loading-indicator');\n    if (loadingIndicator) {\n      loadingIndicator.style.display = 'flex';\n    }\n    \n    // Add a visual feedback that the tap was registered\n    playButton.style.transform = 'scale(0.9)';\n    \n    videoElement.play()\n      .then(() => {\n        playOverlay.remove();\n        if (loadingIndicator) {\n          loadingIndicator.style.display = 'none';\n        }\n      })\n      .catch(error => {\n        console.error('Play failed:', error);\n        \n        // Re-enable the overlay if play fails\n        playOverlay.style.pointerEvents = 'auto';\n        playButton.style.transform = '';\n        \n        if (loadingIndicator) {\n          loadingIndicator.style.display = 'none';\n        }\n        \n        // Show error message\n        showStatusMessage('Auto-play blocked by browser. Please try again or check your browser settings.');\n        \n        // On iOS, we need to mute the video to allow playback without user gesture\n        if (/iPhone|iPad|iPod/i.test(navigator.userAgent)) {\n          videoElement.muted = true;\n          showStatusMessage('Video muted to allow playback on iOS. Tap again to play.');\n        }\n      });\n  };\n  \n  // Add both event listeners for better mobile compatibility\n  playOverlay.addEventListener('click', playHandler);\n  playOverlay.addEventListener('touchend', function(e) {\n    e.preventDefault(); // Prevent default touch behavior\n    playHandler();\n  });\n}\n\n/**\n * Handle video error\n * @param {string} streamName - Name of the stream\n * @param {string} message - Error message\n */\nexport function handleVideoError(streamName, message) {\n  const videoElementId = `video-${streamName.replace(/\\s+/g, '-')}`;\n  const videoElement = document.getElementById(videoElementId);\n  const videoCell = videoElement ? videoElement.closest('.video-cell') : null;\n  \n  if (!videoCell) return;\n  \n  // Hide loading indicator\n  const loadingIndicator = videoCell.querySelector('.loading-indicator');\n  if (loadingIndicator) {\n    loadingIndicator.style.display = 'none';\n  }\n  \n  // Create error indicator if it doesn't exist\n  let errorIndicator = videoCell.querySelector('.error-indicator');\n  if (!errorIndicator) {\n    errorIndicator = document.createElement('div');\n    errorIndicator.className = 'error-indicator';\n    videoCell.appendChild(errorIndicator);\n  }\n  \n  errorIndicator.innerHTML = `\n    <div class=\"error-icon\">!</div>\n    <p>${message || 'Stream connection failed'}</p>\n    <button class=\"retry-button mt-4 px-3 py-1 bg-blue-600 text-white rounded hover:bg-blue-700 transition-colors\">Retry</button>\n  `;\n  \n  // Add retry button handler\n  const retryButton = errorIndicator.querySelector('.retry-button');\n  if (retryButton) {\n    retryButton.addEventListener('click', () => {\n      // Show loading indicator again\n      if (loadingIndicator) {\n        loadingIndicator.style.display = 'flex';\n      }\n      \n      // Hide error indicator\n      errorIndicator.style.display = 'none';\n      \n      // Fetch stream info again and reinitialize\n      fetch(`/api/streams/${encodeURIComponent(streamName)}`)\n        .then(response => response.json())\n        .then(streamInfo => {\n          // Cleanup existing player if any\n          cleanupVideoPlayer(streamName, videoPlayers, detectionIntervals);\n          \n          // Reinitialize\n          initializeVideoPlayer(streamInfo, videoPlayers, detectionIntervals);\n        })\n        .catch(error => {\n          console.error('Error fetching stream info:', error);\n          \n          // Show error indicator again with new message\n          errorIndicator.style.display = 'flex';\n          const errorMsg = errorIndicator.querySelector('p');\n          if (errorMsg) {\n            errorMsg.textContent = 'Could not reconnect: ' + error.message;\n          }\n          \n          // Hide loading indicator\n          if (loadingIndicator) {\n            loadingIndicator.style.display = 'none';\n          }\n        });\n    });\n  }\n}\n\n/**\n * Cleanup video player\n * @param {string} streamName - Name of the stream\n * @param {Object} videoPlayers - Reference to video player instances\n * @param {Object} detectionIntervals - Reference to detection intervals\n */\nexport function cleanupVideoPlayer(streamName, videoPlayers, detectionIntervals) {\n  const videoElementId = `video-${streamName.replace(/\\s+/g, '-')}`;\n  const videoElement = document.getElementById(videoElementId);\n  const videoCell = videoElement ? videoElement.closest('.video-cell') : null;\n  \n  if (!videoCell) return;\n  \n  // Destroy HLS instance and clear refresh timer if they exist\n  if (videoCell.hlsPlayer) {\n    videoCell.hlsPlayer.destroy();\n    delete videoCell.hlsPlayer;\n  }\n  \n  if (videoCell.refreshTimer) {\n    clearInterval(videoCell.refreshTimer);\n    delete videoCell.refreshTimer;\n  }\n  \n  // Reset video element\n  if (videoElement) {\n    videoElement.pause();\n    videoElement.removeAttribute('src');\n    videoElement.load();\n  }\n  \n  // Reset loading indicator\n  const loadingIndicator = videoCell.querySelector('.loading-indicator');\n  if (loadingIndicator) {\n    loadingIndicator.style.display = 'none';\n  }\n  \n  // Remove error indicator if any\n  const errorIndicator = videoCell.querySelector('.error-indicator');\n  if (errorIndicator) {\n    errorIndicator.remove();\n  }\n  \n  // Remove play overlay if any\n  const playOverlay = videoCell.querySelector('.play-overlay');\n  if (playOverlay) {\n    playOverlay.remove();\n  }\n  \n  // Clean up detection polling\n  cleanupDetectionPolling(streamName, detectionIntervals);\n  \n  // Clean up from refs\n  if (videoPlayers[streamName]) {\n    const { hls, refreshTimer } = videoPlayers[streamName];\n    if (hls) {\n      hls.destroy();\n    }\n    if (refreshTimer) {\n      clearInterval(refreshTimer);\n    }\n    delete videoPlayers[streamName];\n  }\n}\n\n/**\n * Stop all streams\n * @param {Array} streams - Array of stream objects\n * @param {Object} videoPlayers - Reference to video player instances\n * @param {Object} detectionIntervals - Reference to detection intervals\n */\nexport function stopAllStreams(streams, videoPlayers, detectionIntervals) {\n  streams.forEach(stream => {\n    cleanupVideoPlayer(stream.name, videoPlayers, detectionIntervals);\n  });\n}\n","/**\n * Snapshot functionality for LiveView\n * This version focuses exclusively on making direct download work\n */\nimport { showStatusMessage, showSnapshotPreview } from './UI.js';\n\n/**\n * Take a snapshot of a stream\n * @param {string} streamId - ID of the stream\n */\nexport function takeSnapshot(streamId) {\n  // Find the stream by ID or name\n  const streamElement = document.querySelector(`.snapshot-btn[data-id=\"${streamId}\"]`);\n  if (!streamElement) {\n    console.error('Stream element not found for ID:', streamId);\n    return;\n  }\n\n  // Get the stream name from the data attribute\n  const streamName = streamElement.getAttribute('data-name');\n  if (!streamName) {\n    console.error('Stream name not found for ID:', streamId);\n    return;\n  }\n\n  // Find the video element\n  const videoElementId = `video-${streamName.replace(/\\s+/g, '-')}`;\n  const videoElement = document.getElementById(videoElementId);\n  if (!videoElement) {\n    console.error('Video element not found for stream:', streamName);\n    return;\n  }\n\n  // Create a canvas element to capture the frame\n  const canvas = document.createElement('canvas');\n  canvas.width = videoElement.videoWidth;\n  canvas.height = videoElement.videoHeight;\n\n  // Check if we have valid dimensions\n  if (canvas.width === 0 || canvas.height === 0) {\n    console.error('Invalid video dimensions:', canvas.width, canvas.height);\n    showStatusMessage('Cannot take snapshot: Video not loaded or has invalid dimensions');\n    return;\n  }\n\n  // Draw the current frame to the canvas\n  const ctx = canvas.getContext('2d');\n  ctx.drawImage(videoElement, 0, 0, canvas.width, canvas.height);\n\n  try {\n    // Save the canvas to global scope for direct access in the overlay\n    window.__snapshotCanvas = canvas;\n    \n    // Generate a filename\n    const timestamp = new Date().toISOString().replace(/[:.]/g, '-');\n    const fileName = `snapshot-${streamName.replace(/\\s+/g, '-')}-${timestamp}.jpg`;\n    window.__snapshotFileName = fileName;\n    \n    // Show the standard preview\n    showSnapshotPreview(canvas.toDataURL('image/jpeg', 0.95), `Snapshot: ${streamName}`);\n    \n    // Find and enhance the download button\n    setTimeout(() => enhanceDownloadButton(), 100);\n    \n    // Show success message\n    showStatusMessage('Snapshot taken successfully');\n  } catch (error) {\n    console.error('Error creating snapshot:', error);\n    showStatusMessage('Failed to create snapshot: ' + error.message);\n  }\n}\n\n/**\n * Find and enhance the download button in the preview\n */\nfunction enhanceDownloadButton() {\n  const overlay = document.getElementById('snapshot-preview-overlay');\n  if (!overlay) {\n    // Try again in 100ms if not found\n    setTimeout(enhanceDownloadButton, 100);\n    return;\n  }\n  \n  // Find download button\n  const buttons = overlay.querySelectorAll('button');\n  let downloadButton = null;\n  \n  for (const button of buttons) {\n    if (button.textContent.includes('Download')) {\n      downloadButton = button;\n      break;\n    }\n  }\n  \n  if (!downloadButton) {\n    // Try again if button not found\n    setTimeout(enhanceDownloadButton, 100);\n    return;\n  }\n  \n  // Replace the download button with our enhanced version\n  const newButton = downloadButton.cloneNode(true);\n  downloadButton.parentNode.replaceChild(newButton, downloadButton);\n  \n  // Add our download handler using Blob+URL.createObjectURL approach\n  newButton.addEventListener('click', () => {\n    // Check if we have a canvas available\n    if (!window.__snapshotCanvas) {\n      console.error('No snapshot canvas available');\n      showStatusMessage('Download failed: No snapshot data available');\n      return;\n    }\n    \n    // Convert canvas to blob and download\n    downloadCanvasAsJpeg(window.__snapshotCanvas, window.__snapshotFileName || 'snapshot.jpg');\n  });\n  \n  console.log('Download button enhanced');\n}\n\n/**\n * Convert canvas to blob and download\n * @param {HTMLCanvasElement} canvas - The canvas to download\n * @param {string} fileName - The filename to use\n */\nfunction downloadCanvasAsJpeg(canvas, fileName) {\n  // Use canvas.toBlob for better browser compatibility\n  canvas.toBlob(function(blob) {\n    if (!blob) {\n      console.error('Failed to create blob from canvas');\n      showStatusMessage('Download failed: Unable to create image data');\n      return;\n    }\n    \n    console.log('Created blob:', blob.size, 'bytes');\n    \n    // Create object URL from blob\n    const blobUrl = URL.createObjectURL(blob);\n    console.log('Created blob URL:', blobUrl);\n    \n    // Create download link\n    const link = document.createElement('a');\n    link.href = blobUrl;\n    link.download = fileName;\n    \n    // Style the link to make it more visible\n    link.style.position = 'absolute';\n    link.style.top = '0';\n    link.style.left = '0';\n    link.style.opacity = '0.01'; // Almost invisible but still technically visible\n    \n    // Add the link to the document\n    document.body.appendChild(link);\n    console.log('Added download link to document');\n    \n    // Trigger click after a short delay\n    setTimeout(() => {\n      console.log('Clicking download link');\n      link.click();\n      \n      // Keep the link in the document for a while\n      setTimeout(() => {\n        // Clean up\n        if (document.body.contains(link)) {\n          document.body.removeChild(link);\n        }\n        URL.revokeObjectURL(blobUrl);\n        console.log('Cleaned up download resources');\n      }, 10000); // Keep resources around for 10 seconds\n    }, 100);\n    \n    showStatusMessage('Download started');\n  }, 'image/jpeg', 0.95); // High quality JPEG\n}","/**\n * Stream grid functionality for LiveView\n */\n\nimport { initializeVideoPlayer } from './VideoPlayer.js';\nimport { takeSnapshot } from './SnapshotManager.js';\nimport { toggleStreamFullscreen } from './FullscreenManager.js';\nimport { showStatusMessage } from './UI.js';\n\n/**\n * Update video grid based on layout and streams\n * @param {HTMLElement} videoGridRef - Reference to video grid element\n * @param {Array} streams - Array of stream objects\n * @param {string} layout - Layout type ('1', '4', '9', '16')\n * @param {string} selectedStream - Selected stream name for single view\n * @param {Object} videoPlayers - Reference to video player instances\n * @param {Object} detectionIntervals - Reference to detection intervals\n */\nexport function updateVideoGrid(\n  videoGridRef, \n  streams, \n  layout, \n  selectedStream, \n  videoPlayers, \n  detectionIntervals\n) {\n  if (!videoGridRef) return;\n  \n  // Clear existing content except placeholder\n  const placeholder = videoGridRef.querySelector('.placeholder');\n  videoGridRef.innerHTML = '';\n  \n  // If placeholder exists and no streams, add it back\n  if (placeholder && streams.length === 0) {\n    videoGridRef.appendChild(placeholder);\n    return;\n  }\n  \n  // Filter streams based on layout and selected stream\n  let streamsToShow = streams;\n  if (layout === '1' && selectedStream) {\n    streamsToShow = streams.filter(stream => stream.name === selectedStream);\n  }\n  \n  // Add video elements for each stream\n  streamsToShow.forEach(stream => {\n    // Ensure we have an ID for the stream (use name as fallback if needed)\n    const streamId = stream.id || stream.name;\n    \n    const videoCell = document.createElement('div');\n    videoCell.className = 'video-cell';\n    \n    videoCell.innerHTML = `\n      <video id=\"video-${stream.name.replace(/\\s+/g, '-')}\" autoplay muted></video>\n      <div class=\"stream-info\">\n        <span>${stream.name}</span>\n        <span>${stream.width}x${stream.height} Â· ${stream.fps}fps</span>\n        <div class=\"stream-controls\">\n          <button class=\"snapshot-btn\" data-id=\"${streamId}\" data-name=\"${stream.name}\">\n            <span>ðŸ“·</span> Snapshot\n          </button>\n          <button class=\"fullscreen-btn\" data-id=\"${streamId}\" data-name=\"${stream.name}\">\n            <span>â›¶</span> Fullscreen\n          </button>\n        </div>\n      </div>\n      <div class=\"loading-indicator\">\n        <div class=\"loading-spinner\"></div>\n        <span>Connecting...</span>\n      </div>\n    `;\n    \n    videoGridRef.appendChild(videoCell);\n    \n    // Initialize video player\n    initializeVideoPlayer(stream, videoPlayers, detectionIntervals);\n    \n    // Add event listeners for buttons\n    const snapshotBtn = videoCell.querySelector('.snapshot-btn');\n    if (snapshotBtn) {\n      snapshotBtn.addEventListener('click', () => {\n        takeSnapshot(streamId);\n      });\n    }\n    \n    const fullscreenBtn = videoCell.querySelector('.fullscreen-btn');\n    if (fullscreenBtn) {\n      fullscreenBtn.addEventListener('click', () => {\n        toggleStreamFullscreen(stream.name);\n      });\n    }\n  });\n}\n\n/**\n * Load streams from API\n * @param {Function} setStreams - State setter for streams\n * @param {Function} setSelectedStream - State setter for selected stream\n * @param {HTMLElement} videoGridRef - Reference to video grid element\n * @returns {Promise<Array>} Promise resolving to array of streams\n */\nexport async function loadStreams(setStreams, setSelectedStream, videoGridRef) {\n  try {\n    // Fetch streams from API\n    const response = await fetch('/api/streams');\n    if (!response.ok) {\n      throw new Error('Failed to load streams');\n    }\n    \n    const data = await response.json();\n    \n    // For live view, we need to fetch full details for each stream\n    // to get detection settings\n    const streamPromises = (data || []).map(stream => {\n      return fetch(`/api/streams/${encodeURIComponent(stream.id || stream.name)}`)\n        .then(response => {\n          if (!response.ok) {\n            throw new Error(`Failed to load details for stream ${stream.name}`);\n          }\n          return response.json();\n        })\n        .catch(error => {\n          console.error(`Error loading details for stream ${stream.name}:`, error);\n          // Return the basic stream info if we can't get details\n          return stream;\n        });\n    });\n    \n    const detailedStreams = await Promise.all(streamPromises);\n    console.log('Loaded detailed streams for live view:', detailedStreams);\n    \n    // Store streams in state\n    setStreams(detailedStreams || []);\n    \n    // If we have streams, set the first one as selected for single view\n    if (detailedStreams.length > 0) {\n      setSelectedStream(detailedStreams[0].name);\n    }\n    \n    return detailedStreams;\n  } catch (error) {\n    console.error('Error loading streams for live view:', error);\n    showStatusMessage('Error loading streams: ' + error.message);\n    \n    return [];\n  }\n}\n","/**\n * LightNVR Web Interface LiveView Component\n * Preact component for the live view page\n */\n\nimport { h } from '../../preact.min.js';\nimport { html } from '../../html-helper.js';\nimport { useState, useEffect, useRef } from '../../preact.hooks.module.js';\nimport { LoadingIndicator } from './LoadingIndicator.js';\n\n// Import modular components\nimport { loadStreams, updateVideoGrid } from './StreamGrid.js';\nimport { stopAllStreams } from './VideoPlayer.js';\nimport { toggleFullscreen, exitFullscreenMode } from './FullscreenManager.js';\n\n/**\n * LiveView component\n * @returns {JSX.Element} LiveView component\n */\nexport function LiveView() {\n  const [streams, setStreams] = useState([]);\n  const [layout, setLayout] = useState('4');\n  const [selectedStream, setSelectedStream] = useState('');\n  const [isFullscreen, setIsFullscreen] = useState(false);\n  const [isLoading, setIsLoading] = useState(true);\n  const videoGridRef = useRef(null);\n  const videoPlayers = useRef({});\n  const detectionIntervals = useRef({});\n  \n  // Set up event listeners\n  useEffect(() => {\n    // Set up Escape key to exit fullscreen mode\n    const handleEscape = (e) => {\n      if (e.key === 'Escape') {\n        console.log(\"Escape key pressed, current fullscreen state:\", isFullscreen);\n        // Check if we're in fullscreen mode by checking the DOM directly\n        const livePage = document.getElementById('live-page');\n        if (livePage && livePage.classList.contains('fullscreen-mode')) {\n          console.log(\"Detected fullscreen mode via DOM, exiting fullscreen\");\n          exitFullscreenMode(null, setIsFullscreen);\n        }\n      }\n    };\n    \n    document.addEventListener('keydown', handleEscape);\n    \n    // Add event listener to stop streams when leaving the page\n    const handleBeforeUnload = () => {\n      stopAllStreams(streams, videoPlayers.current, detectionIntervals.current);\n    };\n    \n    window.addEventListener('beforeunload', handleBeforeUnload);\n    \n    // Cleanup\n    return () => {\n      document.removeEventListener('keydown', handleEscape);\n      window.removeEventListener('beforeunload', handleBeforeUnload);\n      stopAllStreams(streams, videoPlayers.current, detectionIntervals.current);\n    };\n  }, []);\n  \n  // Load streams after the component has rendered and videoGridRef is available\n  useEffect(() => {\n    if (videoGridRef.current) {\n      // Set loading state\n      setIsLoading(true);\n      \n      // Load streams from API\n      loadStreams(setStreams, setSelectedStream, videoGridRef.current)\n        .then(() => {\n          // Hide loading indicator when done\n          setIsLoading(false);\n        })\n        .catch(() => {\n          // Hide loading indicator on error too\n          setIsLoading(false);\n        });\n    }\n  }, [videoGridRef.current]);\n  \n  // Update video grid when layout or streams change\n  useEffect(() => {\n    updateVideoGrid(\n      videoGridRef.current, \n      streams, \n      layout, \n      selectedStream, \n      videoPlayers.current, \n      detectionIntervals.current\n    );\n  }, [layout, selectedStream, streams]);\n  \n  return html`\n    <section id=\"live-page\" class=\"page\">\n      <div class=\"page-header flex justify-between items-center mb-4 p-4 bg-white dark:bg-gray-800 rounded-lg shadow\">\n        <div class=\"flex items-center space-x-2\">\n          <h2 class=\"text-xl font-bold mr-4\">Live View</h2>\n          <div class=\"flex space-x-2\">\n            <button \n              id=\"webrtc-toggle-btn\" \n              class=\"px-3 py-2 bg-green-600 text-white rounded-md hover:bg-green-700 transition-colors focus:outline-none focus:ring-2 focus:ring-green-500 focus:ring-offset-2 dark:focus:ring-offset-gray-800\"\n              onClick=${() => window.location.href = '/index.html'}\n            >\n              Live View (WebRTC)\n            </button>\n            <button \n              id=\"fullscreen-btn\" \n              class=\"px-3 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700 transition-colors focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2 dark:focus:ring-offset-gray-800\"\n              onClick=${() => toggleFullscreen(isFullscreen, setIsFullscreen)}\n            >\n              Fullscreen\n            </button>\n          </div>\n        </div>\n        <div class=\"controls flex items-center space-x-2\">\n          <select \n            id=\"layout-selector\" \n            class=\"px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-blue-500 focus:border-blue-500 dark:bg-gray-700 dark:border-gray-600\"\n            value=${layout}\n            onChange=${(e) => setLayout(e.target.value)}\n          >\n            <option value=\"1\">Single View</option>\n            <option value=\"4\" selected>2x2 Grid</option>\n            <option value=\"9\">3x3 Grid</option>\n            <option value=\"16\">4x4 Grid</option>\n          </select>\n          \n          ${layout === '1' && html`\n            <select \n              id=\"stream-selector\" \n              class=\"px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-blue-500 focus:border-blue-500 dark:bg-gray-700 dark:border-gray-600\"\n              value=${selectedStream}\n              onChange=${(e) => setSelectedStream(e.target.value)}\n            >\n              ${streams.map(stream => html`\n                <option key=${stream.name} value=${stream.name}>${stream.name}</option>\n              `)}\n            </select>\n          `}\n        </div>\n      </div>\n      \n      <div \n        id=\"video-grid\" \n        class=${`video-container layout-${layout}`}\n        ref=${videoGridRef}\n      >\n        ${isLoading ? html`\n          <div class=\"flex justify-center items-center col-span-full row-span-full h-64 w-full\">\n            <${LoadingIndicator} message=\"Loading streams...\" size=\"lg\" />\n          </div>\n        ` : streams.length === 0 ? html`\n          <div class=\"placeholder flex flex-col justify-center items-center col-span-full row-span-full bg-white dark:bg-gray-800 rounded-lg shadow-md text-center p-8\">\n            <p class=\"mb-6 text-gray-600 dark:text-gray-300 text-lg\">No streams configured</p>\n            <a href=\"streams.html\" class=\"btn-primary px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700 transition-colors\">Configure Streams</a>\n          </div>\n        ` : null}\n        <!-- Video cells will be dynamically added by the updateVideoGrid function -->\n      </div>\n    </section>\n  `;\n}\n\n/**\n * Load LiveView component\n */\nexport function loadLiveView() {\n  const mainContent = document.getElementById('main-content');\n  if (!mainContent) return;\n  \n  // Render the LiveView component to the container\n  import('../../preact.min.js').then(({ render }) => {\n    render(html`<${LiveView} />`, mainContent);\n  });\n}\n"],"names":["initializeVideoPlayer","stream","videoPlayers","detectionIntervals","videoElementId","name","replace","videoElement","document","getElementById","videoCell","closest","canvasId","canvasOverlay","createElement","id","className","style","position","top","left","width","height","pointerEvents","appendChild","console","log","detection_based_recording","detection_model","detection_threshold","startDetectionPolling","loadingIndicator","querySelector","display","timestamp","Date","now","hlsStreamUrl","encodeURIComponent","localStorage","getItem","canPlayType","src","addEventListener","e","error","handleVideoError","message","play","catch","warn","addPlayButtonOverlay","window","Hls","isSupported","auth","isMobile","test","navigator","userAgent","hls","maxBufferLength","maxMaxBufferLength","liveSyncDurationCount","liveMaxLatencyDurationCount","liveDurationInfinity","lowLatencyMode","enableWorker","fragLoadingTimeOut","manifestLoadingTimeOut","levelLoadingTimeOut","backBufferLength","startLevel","abrEwmaDefaultEstimate","abrBandWidthFactor","abrBandWidthUpFactor","xhrSetup","xhr","url","setRequestHeader","withCredentials","loadSource","attachMedia","on","Events","MANIFEST_PARSED","muted","setTimeout","then","ERROR","event","data","fatal","destroy","textContent","fetch","response","json","updatedStream","cleanupVideoPlayer","messageSpan","newTimestamp","newUrl","newHls","hlsPlayer","refreshTimer","MEDIA_ATTACHED","newData","type","ErrorTypes","NETWORK_ERROR","currentTime","recoverMediaError","duration","details","ErrorDetails","FRAG_LOAD_ERROR","FRAG_LOAD_TIMEOUT","currentLevel","MEDIA_ERROR","setInterval","autoLevelCapping","clearInterval","playOverlay","playButton","innerHTML","tapMessage","color","marginTop","fontSize","playHandler","transform","remove","showStatusMessage","preventDefault","streamName","errorIndicator","retryButton","streamInfo","errorMsg","pause","removeAttribute","load","cleanupDetectionPolling","stopAllStreams","streams","forEach","enhanceDownloadButton","overlay","buttons","querySelectorAll","downloadButton","button","includes","newButton","cloneNode","parentNode","replaceChild","__snapshotCanvas","canvas","fileName","__snapshotFileName","toBlob","blob","size","blobUrl","URL","createObjectURL","link","href","download","opacity","body","click","contains","removeChild","revokeObjectURL","updateVideoGrid","videoGridRef","layout","selectedStream","placeholder","length","streamsToShow","filter","streamId","fps","snapshotBtn","streamElement","getAttribute","videoWidth","videoHeight","getContext","drawImage","toISOString","showSnapshotPreview","toDataURL","takeSnapshot","fullscreenBtn","toggleStreamFullscreen","LiveView","setStreams","useState","setLayout","setSelectedStream","isFullscreen","setIsFullscreen","isLoading","setIsLoading","useRef","useEffect","handleEscape","key","livePage","classList","exitFullscreenMode","handleBeforeUnload","current","removeEventListener","async","ok","Error","streamPromises","map","detailedStreams","Promise","all","loadStreams","html","location","toggleFullscreen","target","value","LoadingIndicator","mainContent","__vitePreload","render","module","import","n","p","meta"],"mappings":"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"}