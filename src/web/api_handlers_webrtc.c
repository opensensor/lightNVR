#define _XOPEN_SOURCE
#define _GNU_SOURCE

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <ctype.h>
#include <stdbool.h>

#include "web/api_handlers_streaming.h"
#include "web/api_handlers_common.h"
#include "web/request_response.h"
#include "core/config.h"
#include "core/logger.h"
#include "video/stream_manager.h"
#include "video/streams.h"

/**
 * URL decode function (deprecated, use url_decode from request_response.h instead)
 */
static void url_decode_stream(char *str) {
    if (!str) return;
    
    char decoded[MAX_STREAM_NAME];
    url_decode(str, decoded, sizeof(decoded));
    strncpy(str, decoded, MAX_STREAM_NAME - 1);
    str[MAX_STREAM_NAME - 1] = '\0';
}

/**
 * Handle WebRTC offer request - simple placeholder implementation
 */
void handle_webrtc_offer(const http_request_t *request, http_response_t *response) {
    // Extract stream name from URL
    const char *path = request->path;
    const char *streams_pos = strstr(path, "/streaming/");

    if (!streams_pos) {
        create_stream_error_response(response, 400, "Invalid request path");
        return;
    }

    const char *stream_name_start = streams_pos + 11;  // Skip "/streaming/"
    const char *webrtc_pos = strstr(stream_name_start, "/webrtc/");

    if (!webrtc_pos) {
        create_stream_error_response(response, 400, "Invalid WebRTC request path");
        return;
    }

    // Extract stream name
    char stream_name[MAX_STREAM_NAME];
    size_t name_len = webrtc_pos - stream_name_start;

    if (name_len >= MAX_STREAM_NAME) {
        create_stream_error_response(response, 400, "Stream name too long");
        return;
    }

    memcpy(stream_name, stream_name_start, name_len);
    stream_name[name_len] = '\0';

    // URL decode the stream name
    char decoded_stream[MAX_STREAM_NAME];
    url_decode(stream_name, decoded_stream, sizeof(decoded_stream));
    strncpy(stream_name, decoded_stream, MAX_STREAM_NAME - 1);
    stream_name[MAX_STREAM_NAME - 1] = '\0';

    // Check if stream exists
    stream_handle_t stream = get_stream_by_name(stream_name);
    if (!stream) {
        create_stream_error_response(response, 404, "Stream not found");
        return;
    }

    // In a real implementation, this would:
    // 1. Parse the WebRTC offer from the request body
    // 2. Use the libWebRTC or similar library to create an answer
    // 3. Send the answer back to the client

    // For now, just acknowledge the request with a placeholder

    log_info("Received WebRTC offer for stream %s", stream_name);

    // Create placeholder response
    const char *response_json = "{\"status\": \"acknowledged\", \"message\": \"WebRTC not yet implemented\"}";

    response->status_code = 200;
    strncpy(response->content_type, "application/json", sizeof(response->content_type) - 1);
    response->content_type[sizeof(response->content_type) - 1] = '\0';
    response->body = strdup(response_json);

    // Indicate that body should be freed (if needed)
    // response->needs_free = 1;
}

/**
 * Handle WebRTC ICE request
 */
void handle_webrtc_ice(const http_request_t *request, http_response_t *response) {
    // This is a placeholder implementation
    // In a real implementation, we would process the WebRTC ICE candidates
    
    log_info("WebRTC ICE request: %s", request->path);
    
    // For now, just return a 501 error (not implemented)
    create_stream_error_response(response, 501, "WebRTC not implemented");
}
