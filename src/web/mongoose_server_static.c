#include <stdio.h>
#include <stdlib.h>

#include <string.h>
#include <sys/stat.h>
#include <fcntl.h>

#include "web/mongoose_server_static.h"
#include "core/logger.h"
#include "core/config.h"
#include "video/streams.h"

// Include Mongoose
#include "mongoose.h"

/**
 * @brief Handle static file request
 */
void mongoose_server_handle_static_file(struct mg_connection *c, struct mg_http_message *hm, http_server_t *server) {
    // Extract URI
    char uri[MAX_PATH_LENGTH];
    size_t uri_len = hm->uri.len < sizeof(uri) - 1 ? hm->uri.len : sizeof(uri) - 1;
    memcpy(uri, hm->uri.buf, uri_len);
    uri[uri_len] = '\0';

    // Check if this is an API request
    if (strncmp(uri, "/api/", 5) == 0) {
        // API endpoint not found
        mg_http_reply(c, 404, "", "{\"error\": \"API Endpoint Not Found\"}\n");
        return;
    }
    
    // Special case for HLS streaming files
    if (strncmp(uri, "/hls/", 5) == 0) {
        // This is an HLS streaming request, serve it directly from the filesystem
        config_t *global_config = get_streaming_config();
        
        // Extract stream name from URI
        // URI format: /hls/{stream_name}/{file}
        char stream_name[MAX_STREAM_NAME];
        const char *stream_start = uri + 5; // Skip "/hls/"
        const char *file_part = strchr(stream_start, '/');
        
        if (!file_part) {
            mg_http_reply(c, 404, "", "{\"error\": \"Invalid HLS path\"}\n");
            return;
        }
        
        // Extract stream name
        size_t name_len = file_part - stream_start;
        if (name_len >= MAX_STREAM_NAME) {
            name_len = MAX_STREAM_NAME - 1;
        }
        strncpy(stream_name, stream_start, name_len);
        stream_name[name_len] = '\0';
        
        // Extract file name (everything after the stream name)
        const char *file_name = file_part + 1; // Skip "/"
        
        // Construct the full path to the HLS file
        char hls_file_path[MAX_PATH_LENGTH];
        snprintf(hls_file_path, sizeof(hls_file_path), "%s/hls/%s/%s", 
                global_config->storage_path, stream_name, file_name);
        
        log_info("Serving HLS file directly: %s", hls_file_path);
        
        // Check if file exists
        struct stat st;
        if (stat(hls_file_path, &st) == 0 && S_ISREG(st.st_mode)) {
            // Determine content type based on file extension
            const char *content_type = "application/octet-stream"; // Default
            if (strstr(file_name, ".m3u8")) {
                content_type = "application/vnd.apple.mpegurl";
            } else if (strstr(file_name, ".ts")) {
                content_type = "video/mp2t";
            }
            
            // Serve the file with appropriate headers
            mg_http_serve_file(c, hm, hls_file_path, &(struct mg_http_serve_opts){
                .mime_types = "",
                .extra_headers = "Cache-Control: no-cache, no-store, must-revalidate\r\n"
                                "Pragma: no-cache\r\n"
                                "Expires: 0\r\n"
                                "Access-Control-Allow-Origin: *\r\n"
            });
            return;
        } else {
            // File doesn't exist - let the client know
            // We don't need to create dummy files since FFmpeg integration 
            // is responsible for creating the actual HLS files
            log_info("HLS file not found: %s (waiting for FFmpeg to create it)", hls_file_path);
            
            // Return a 404 with a message that indicates the file is being generated
            mg_http_reply(c, 404, "", "{\"error\": \"HLS file not found or still being generated by FFmpeg\"}\n");
            return;
        }
    }

    // Construct file path
    char file_path[MAX_PATH_LENGTH * 2];
    snprintf(file_path, sizeof(file_path), "%s%s", server->config.web_root, uri);

    // If path ends with '/', append 'index.html'
    size_t path_len = strlen(file_path);
    if (file_path[path_len - 1] == '/') {
        strncat(file_path, "index.html", sizeof(file_path) - path_len - 1);
    }

    // Check if file exists
    struct stat st;
    if (stat(file_path, &st) == 0) {
        // Check if it's a directory
        if (S_ISDIR(st.st_mode)) {
            // Redirect to add trailing slash if needed
            if (uri[strlen(uri) - 1] != '/') {
                char redirect_path[MAX_PATH_LENGTH * 2];
                snprintf(redirect_path, sizeof(redirect_path), "%s/", uri);
                mg_http_reply(c, 301, "Location: %s\r\n", redirect_path);
                return;
            } else {
                // Try to serve index.html
                strncat(file_path, "index.html", sizeof(file_path) - strlen(file_path) - 1);
                if (stat(file_path, &st) != 0 || !S_ISREG(st.st_mode)) {
                    mg_http_reply(c, 403, "", "403 Forbidden\n");
                    return;
                }
            }
        }

        // Serve the file
        struct mg_http_serve_opts opts = {
            .root_dir = server->config.web_root,
            .mime_types = "html=text/html,htm=text/html,css=text/css,js=application/javascript,"
                         "json=application/json,jpg=image/jpeg,jpeg=image/jpeg,png=image/png,"
                         "gif=image/gif,svg=image/svg+xml,ico=image/x-icon,mp4=video/mp4,"
                         "webm=video/webm,ogg=video/ogg,mp3=audio/mpeg,wav=audio/wav,"
                         "txt=text/plain,xml=application/xml,pdf=application/pdf"
        };
        mg_http_serve_file(c, hm, file_path, &opts);
        return;
    }

    // File doesn't exist - check SPA routes
    // List of known SPA routes
    const char *spa_routes[] = {
        "/",
        "/recordings",
        "/streams",
        "/settings",
        "/system",
        "/debug",
        NULL  // Terminator
    };

    // Check if the path matches a known SPA route
    bool is_spa_route = false;
    for (int i = 0; spa_routes[i] != NULL; i++) {
        if (strcmp(uri, spa_routes[i]) == 0) {
            is_spa_route = true;
            break;
        }
    }

    // If it's a known SPA route or path with assumed dynamic segments (/recordings/123)
    // Serve the index.html file
    if (is_spa_route ||
        strncmp(uri, "/recordings/", 12) == 0 ||
        strncmp(uri, "/streams/", 9) == 0) {

        char index_path[MAX_PATH_LENGTH * 2];
        snprintf(index_path, sizeof(index_path), "%s/index.html", server->config.web_root);

        // Check if index.html exists
        if (stat(index_path, &st) == 0 && S_ISREG(st.st_mode)) {
            // Serve index.html
            struct mg_http_serve_opts opts = {
                .root_dir = server->config.web_root,
                .mime_types = "html=text/html"
            };
            mg_http_serve_file(c, hm, index_path, &opts);
            return;
        }
    }

    // File not found
    mg_http_reply(c, 404, "", "404 Not Found\n");
}

/**
 * @brief Set maximum connections
 */
int http_server_set_max_connections(http_server_handle_t server, int max_connections) {
    if (!server || max_connections <= 0) {
        return -1;
    }

    server->config.max_connections = max_connections;
    log_info("Maximum connections set to %d", max_connections);
    return 0;
}

/**
 * @brief Set connection timeout
 */
int http_server_set_connection_timeout(http_server_handle_t server, int timeout_seconds) {
    if (!server || timeout_seconds <= 0) {
        return -1;
    }

    server->config.connection_timeout = timeout_seconds;
    log_info("Connection timeout set to %d seconds", timeout_seconds);
    return 0;
}
